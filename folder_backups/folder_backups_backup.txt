########## routes_backup.txt ##########
########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})






########## github_backup.txt ##########
########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'






########## folder_backups_backup.txt ##########
########## routes_backup.txt ##########
########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})






########## github_backup.txt ##########
########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'






########## prompts_backup.txt ##########
########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.





########## tests_backup.txt ##########
########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)






########## Logs_backup.txt ##########
########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.






########## utils_backup.txt ##########
########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)






########## code_text_backup.txt ##########
########## env.txt ##########
OPENAI_API_KEY='sk-proj-9FMlNRVjatGHs2Gu058BT3BlbkFJHK3n2HBzVzzWnwGw3Eqh'
GITHUB_TOKEN='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'
ASSISTANT_API_KEY='asst_7pKEzlqGiYzHbs1v0LscYoxe'
PINECONE_API_KEY='333283cc-9630-4a52-b47d-1898d2a1da77'
PINECONE_INDEX_NAME='yean-cat-git-gpt-index'
GITHUB_USERNAME='JayArnoldProd'


########## update_lists.sh.txt ##########
#!/bin/bash

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Commit and push the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"



########## deploy_all.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## Procfile.txt ##########
web: gunicorn server:app



########## gitattributes.txt ##########
# Auto detect text files and perform LF normalization
* text=auto



########## intro.txt ##########
You are an AI assistant helping with the development of a 2D side-scrolling open world game in the 'survivors' genre using GameMaker Studio 2. The game includes multiplayer functionality, rhythm-based elements, and extensive object interactions. I have created a program that will allow me to communicate with gpt, and automates the process of sending my most recent code (from GitHub) to the AI. You will receive a description of the bug or feature I want you to help me with, along with any code I believe to be relevant for my request. I will also attach a log of my in game console, which I can test features and effectively communicate to you with. Since I am using API integration, sadly you will not remember any of our conversations, which is why you will be receiving so much information. Please make the most educated attempt at bringing me closer to the desired feature or bug fix. If you are not confident enough to solve my issue because you would need to see a specific script that I have not provided you with, then let me know. Please reuse and fix existing code, before adding scripts for things I might already have. Do not assume I have a script for a certain thing if you don't see evidence of it in the code I have provided you.


########## requirements.txt ##########
blinker==1.8.2
brotlipy==0.7.0
certifi==2022.12.7
cffi==1.15.1
charset-normalizer==2.1.1
click==8.1.7
Flask==3.0.3
gunicorn==22.0.0
idna==3.4
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
numpy==1.24.2
python-dotenv==1.0.1
requests==2.28.1
setuptools==69.2.0
wheel==0.43.0
Werkzeug==3.0.3
pinecone-client==4.1.1


########## format_description.txt ##########
If you are creating a new in-game, executable script, it should start with scr_ and be well-documented. In addition to creating the script with the correct naming format, I also need a line of code that adds the command to the command list.

For Example:
/// @function scr_return_controller()
/// @description Outputs the connected gamepad description or a message if none are connected
function scr_return_controller() {
    if (gamepad_is_connected(0)) {
        var gpad_desc = gamepad_get_description(0);
        handleDebugMessage("Connected gamepad: " + gpad_desc, true);
    } else {
        handleDebugMessage("No gamepad detected.", true);
    }
}

add_command("command name (without scr_, if needs argument(s): ends with '(')", (permission level required), [["string", "real"]] (2D array defining accepted var types for each argument, boolean (whether this command needs at least 1 argument passed));

Permission levels:
0 -> Player
1 -> Moderator
2 -> Developer
3 -> Owner

For Example: 
add_command("set_variable(", 2, [["string"],["string","real"]],true)
add_command("save_game", 0, [[]], false);  // Does not require "(" visually

*Remember this is only needed if you are adding a new command to the game, try and reuse existing scripts as much as possible and let me know if you would need to see a specific script that was not included, but could be helpful in resolving the issue! Remember that you are a 1 time chat interaction and will have no memory of this so If you cant see the solution to the bug or the method to adding the desired feature, then simply reply with what else you need to see in my code.

The game features an in game console which allows players with the required permission to execute code and create new features from within the game. Typing "/" will mean that the player is typing a command. Some commands do not require a "(", for example: /toggle_server . You can create actions by typing /add_action("Name it",Command_name,[100,"example_string"]) and can create macros essentially for commands and will be able to trigger these actions in sequences and events, or possibly controlled by an AI GPT like yourself. This is how It is intended to work, but it is still needing some fixes to be able to handle saving actions for commands that take more than 1 argument, such as /chat_bubble("Text",owner). 


########## runtime.txt ##########
python-3.10.14


########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)



########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)



########## deploy.sh.txt ##########
#!/bin/bash

# Navigate to the project directory
cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Add and commit the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"

# Push to Heroku
git push heroku main



########## pyproject.toml.txt ##########
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"



########## bug_list.json.txt ##########
        [
            {
                "name": "Console Bug",
                "description": "The main bug in my game that needs fixing is that for some reason, typing /add_action(Lvl100,level_up,[100]) works and creates a reusable action named,Lvl100. Typing /execute_action(Lvl100) will level up the player 100 times. The issuse is when I try to create an action with 2 or more arguments, something goes wrong. For example: /add_action(HelloWorld,chat_bubble,[Hello World!,yeancat]) does not work. It says that it created an action, but when I try to execute the action, it throws an error (see cliet logs). I have reason to believe the saving of the actions is where this goes wrong. (scr_add_action)",
                "related_objects": ["obj_Client"],
                "related_scripts": ["execute_command", "scr_add_action", "scr_execute_action", "save_actions", "load_actions", "parse_arguments", "parse_data_types", "handleDebugMessage", "handleCommandWithArgs"],
                "logs": ["SessionLog_45453.16.txt"]
            }
        ]



########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.



########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'



########## planned_features.json.txt ##########
[
    {
        "name": "Sample Feature",
        "description": "This is a sample feature description.",
        "related_objects": ["obj_client", "dondadollar"],
        "related_scripts": ["scr_toggle_server", "scr_list_colors"],
        "logs": ["SessionLog_45450.51.txt"]
    }
]



########## backup.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.


########## command_list.txt ##########
add_action
add_color
betterdirection
calculate_spent
chat_bubble
disable_heartbeat
enable_heartbeat
execute_action
game_end
goto_planet
jump_planet
level_up
list_actions
list_clients
list_colors
list_commands
list_variables
load_game
loadtrack
loadtrack2
name_color
return_controller
save_actions
save_game
save_macros
savetrack
set_my_permission
set_variable
show_gamepad_mapping
show_lines
show_variable
show_wpm
slider_cluster
toggle_debug
toggle_input_display
toggle_log_debug
toggle_server



########## slugignore.txt ##########
.git
*.log
node_modules
__pycache__
*.pyc
.DS_Store
tests
.env
conda-meta
lib/python*/site-packages/conda
lib/python*/site-packages/tensorboardX
lib/python*/site-packages/protobuf
YEAN CAT/sprites
YEAN CAT/sounds
deploy.sh


########## script_list.txt ##########
is_numeric_string
__input_config_gamepads
input_check_opposing_repeat
input_source_mode_get
__input_config_keyboard
calculateAngle
change_input_color
countLinesInString
input_trigger_effect_get_strength
string_last_index_of
scr_toggle_input_display
__input_class_player
input_cursor_coord_space_set
scr_disable_heartbeat
input_cursor_limit_boundary
sort_score
input_binding_scan_time_remaining
input_mouse_y
input_system_import
input_debug_player_input
input_player_get_gamepad
input_players_get_status
input_gamepad_check_released
__input_csv_to_array
input_system_export
parse_data_types
input_profile_copy
input_cursor_elastic_set
FirebaseFirestoreUserFunctions
__input_class_combo_state
adjustAngle
input_hotswap_params_set
input_profile_get_array
FirebaseREST_firestore_value
concat
__input_string_contains
input_mouse_x
input_ignore_key_add
__input_define_gamepad_types
input_cursor_speed_set
FirebaseFirestorePaths
FriebaseREST_Firestore_urlUpdateMask
input_check_opposing
input_vibrate_set_strength
input_verb_get_icon
__input_source_relinquish
__input_error
input_check_long
FirebaseREST_Firestore_path_isCollection
input_keyboard_virtual_show
input_system_reset
scr_loadtrack2
input_trigger_effect_get_state
logChatMessage
input_binding_mouse_wheel_down
input_player_connected_count
__input_config_external_data
__input_get_previous_time
input_combo_params_set_side_on
FirebaseREST_Firestore_collection_decode
input_binding_scan_start
input_mouse_capture_get
input_cursor_limit_remove
input_player_connected
update_chat_input_visuals
input_source_is_available
__input_config_profiles
input_mouse_check
input_binding_get_icon
input_check_long_pressed
input_player_active_set
currentSyncedTime
input_is_analogue
input_vibrate_constant
__input_restart_get
input_mouse_wheel_up
input_binding_get_name
input_source_share
__input_restart
scr_save_game
scr_return_controller
syncTimeWithServer
scr_game_end
__input_gamepad_set_blacklist
__input_gamepad_tester_init
__input_class_trigger_effect_vibration
input_binding_threshold_get
drawChatMessages
input_profile_destroy
input_combo_get_new_phase
scr_show_lines
input_accessibility_global_cooldown_get
seconds_to_time
input_virtual_destroy_all
input_cursor_translate
__input_gamepad_tester_build_gui
__input_class_icon_category
input_binding_set
__input_ensure_unique_verb_name
__input_config_verbs
__input_wrap_underflow
input_verb_groups_get
__input_class_virtual
FirebaseFirestore_operationFromSymbol
input_axis_threshold_get
input_player_ghost_set
input_mouse_wheel_down
input_verb_group_is_active
input_check_repeat
input_window_has_focus
__input_class_verb_state
input_gamepad_value
input_combo_get_charge
last_key_is_valid_character
input_clear_momentary
input_source_add
input_color_reset
__input_gamepad_guid_parse
input_icons
input_profile_verify
input_source_detect_input
input_cursor_inverted_set
input_combo_create
input_source_get_array
input_color_get
__input_mouse_button
input_mouse_check_released
input_debug_all_input
input_check_double_released
__input_gamepad_tester_destroy_gui
calculatePlayerStats
input_player_get_invalid_gamepad_bindings
save_actions
seconds_to_formatted_string
check_permission
input_binding_scan_params_get
input_binding_virtual_button
scr_set_my_permission
scr_list_variables
formatChatInput
input_profile_exists
__input_hotswap_tick
__input_load_type_csv
input_check_press_most_recent
input_binding_swap
input_player_using_keyboard
scr_show_gamepad_mapping
input_cursor_gyro_enabled_set
input_accessibility_verb_toggle_set
__input_key_get_name
input_player_disconnect
__input_gamepad_set_mapping
player_data_needs_update
__input_config_icons
input_binding_mouse_button
__input_config_general
__input_gamepad_find_in_sdl2_database
input_mouse_moved
scr_enable_heartbeat
__input_system_tick
execute_command
scr_list_clients
input_max_value
input_player_reset
__input_class_trigger_effect_off
input_trigger_effect_set_pause
__input_initialize
input_verb_consume
scr_execute_action
input_cursor_mouse_enabled_get
scr_chat_bubble
input_icons_keyboard_and_mouse
scr_goto_planet
scr_toggle_server
scr_calculate_spent
__input_keyboard_key
input_source_clear
scr_savetrack
input_mouse_coord_space_set
input_player_gamepad_type_override_get
__input_multiplayer_assignment_tick
input_check_quick_pressed_2d
input_gamepad_delta
input_distance
input_binding_get_source_type
input_profile_reset_bindings
FirebaseREST_Firestore_jsonDecode
input_trigger_effect_set_strength
FirebaseREST_parse
input_gamepad_check_pressed
scr_betterdirection
input_player_import
input_icon_not_a_binding
instance_nearest_notme
parse_arguments
input_gamepads_get_status
input_profile_set
input_combo_get_phase
FirebaseREST_firestore_fieldReference
FirebaseREST_Firestore_getURL
input_player_export
input_keyboard_check_pressed
input_binding_scan_abort
input_join_params_set
input_virtual_create
input_player_swap
input_trigger_effect_get_pause
FirebaseREST_asyncCall_Firestore
updateWPM
input_verb_group_get_verbs
FirebaseREST_HTTP_Failed_Firestore
__input_player_apply_trigger_effects
input_combo_get_direction
input_vibrate_get_strength
input_gamepad_is_connected
input_gamepad_tester_set
input_players_using_source
input_accessibility_global_toggle_set
draw_text_bold
input_keyboard_check
input_check
input_source_detect_new
input_binding_gamepad_axis
input_source_set
input_cursor_elastic_remove
input_binding_mouse_wheel_up
input_combo_get_phase_count
input_accessibility_verb_cooldown_get
__input_load_sdl2_from_string
scr_toggle_log_debug
input_player_using_mouse
add_variable
update_game_state
string_word_count
json_compare
__input_axis_is_directional
__input_config_mouse
input_mouse_in_bounds
input_cursor_gyro_params_set
scr_save_macros
input_binding_gamepad_set
FirebaseListenerUserFunctions_Firestore
__input_class_combo_definition
input_cursor_limit_get
instance_nearest_notme2
scr_add_action
scr_jump_planet
__input_config_verb_behaviour
FirebaseREST_asyncFunction_Firestore
FirebaseREST_Firestore_jsonEncode
input_player_verify
input_held_time
input_gamepad_check
string_trim_right
__input_config_combos
input_binding_get
__input_config_vibration
input_profile_auto
input_check_quick_pressed
handleDebugMessage
input_binding_remove
input_gamepad_get_type
scr_toggle_debug
string_remove_between
input_axis_threshold_set
check_control_type
input_player_ghost_get
__input_load_sdl2_from_buffer_legacy
input_check_double
input_combo_params_get
draw_rectangle_outlined
input_mouse_dx
__input_gamepad_value_internal
scr_load_game
input_binding_key
add_command
__input_key_is_ignored
input_check_long_released
level_up
string_is_real
check_tasks
string_contains
FirebaseFirestoreMainFunctions
input_accessibility_global_cooldown_set
scr_set_variable
input_binding_scan_params_clear
input_check_double_pressed
FirebaseREST_Firestore_collection_query_decode
input_binding_threshold_set
__input_config_multiplayer
draw_text_bold_ext2
input_mouse_dy
appendAndWrap
input_virtual_debug_draw
input_binding_empty
input_player_active_get
handleCommandWithArgs
__input_gamepad_set_vid_pid
scr_level_up
load_actions
__input_snap_to_json
adjust_pitch
is_valid_email
__input_class_gamepad_mapping
scr_slider_cluster
__input_gamepad_stop_trigger_effects
scr_name_color
get_longest_word_width
input_chord_create
input_mouse_capture_set
__input_macros
draw_text_bold_ext
input_cursor_speed_get
input_game_has_focus
input_hotswap_params_get
forceLineBreakAtMaxWidth
FirebasePathsUserFunctions
input_radial_sector
__input_class_source
__input_binding_get_label
input_led_pattern_get
__input_gamepad_reset_color
input_x
FirebaseREST_firestore_cursor
__input_class_trigger_effect_weapon
scr_save_actions
input_cursor_elastic_get
scr_show_variable
input_gamepad_is_any_connected
input_cursor_set
input_check_pressed
handleNetworkData
FirebaseREST_firestore_value_json
get_delta_time
input_combo_reset
__input_class_gamepad_motion
input_y
__input_class_vibration_pulse
input_gamepad_get_map
__input_class_vibration_constant
__input_class_vibration_adsr
wrap_text
input_source_mode_set
input_trigger_effect_vibration
scr_list_colors
checkAndSpawnEnemies
input_cursor_coord_space_get
input_binding_scan_in_progress
__input_player_tick_sources
input_source_using
__input_class_vibration_curve
scr_show_wpm
input_keyboard_virtual_hide
__input_global
input_mouse_check_pressed
input_gamepad_is_axis
input_player_using_touch
__input_class_chord_definition
input_vibrate_pulse
input_trigger_effect_feedback
input_cursor_limit_circle
input_accessibility_verb_cooldown_set
input_direction
__input_config_touch
input_ignore_key_remove
input_cursor_gyro_params_get
input_binding_gamepad_get
check_permission_command
input_vibrate_curve
FirebaseREST_HTTP_Success_Firestore
__input_class_cursor
input_verb_group_active
__input_config_verb_groups
input_held_time_released
input_value
input_icons_gamepad
input_trigger_effect_weapon
FirebaseREST_Firestore_collection_compare
getMessageHeight
input_player_using_gamepad
input_vibrate_stop
input_cursor_limit_aabb
__input_class_gamepad
input_motion_data_get
input_gamepad_tester_get
input_accessibility_global_toggle_get
__input_steam_type_set
__input_gamepad_set_description
input_profile_export
input_profile_get
input_value_is_binding
__input_exception_handler
array_to_string
input_vibrate_set_pause
FirebaseREST_Firestore_headerToken
__input_window_changed
__input_trace_loud
__input_gamepad_type_swap_ab
scr_loadtrack
input_player_get_gamepad_type
angle_distance
input_join_params_get
__input_config_hotswap
input_gamepad_map_contains
input_trigger_effect_off
__input_load_blacklist_csv
input_verb_get_group
input_mouse_coord_space_get
input_player_gamepad_type_override_set
__input_trace
__input_clear_all
shortestAngularDistance
input_keyboard_check_released
shortestAngularDirection
input_check_opposing_pressed
__input_virtual_player_set
__input_gamepad_tester_tick
input_profile_import
__input_validate_macros
input_join_is_finished
FirebaseREST_Firestore_path_isDocument
__input_transform_coordinate
__input_finalize_default_profiles
input_profile_create
__input_class_chord_state
drawTextWithOutline
input_vibrate_get_pause
input_cursor_mouse_enabled_set
input_binding_is_valid
input_cursor_dy
__input_class_binding
update_audio_pitch
draw_healthbar_border
input_system_verify
input_verb_set
input_combo_params_reset
input_icon_touch
input_binding_test_collisions
__input_gamepad_set_type
input_gamepad_get_description
scr_add_color
parse_action_parameters
input_cursor_gyro_enabled_get
scr_resolution
scr_list_commands
input_accessibility_verb_toggle_get
__input_get_time
scr_list_actions
are_arguments_valid
calculate_color_distance
input_cursor_y
input_binding_get_verbs
load_responses
input_gamepad_constant_get_name
input_binding_scan_params_set
input_is_virtual
input_player_copy
input_cursor_dx
input_xy
updateLongestMessage
draw_text_kern
input_combo_params_set_top_down
__input_steam_handles_changed
input_cursor_x
__input_class_trigger_effect_feedback
__input_load_sdl2_from_string_internal
__input_load_sdl2_from_file
debug_action_details
input_cursor_inverted_get
__input_finalize_verb_groups
input_color_set
input_binding_gamepad_button
input_icon_empty
check_gamepad_input
command_requires_arguments
__input_config_cursor
input_check_released
input_vibrate_adsr
input_binding_set_safe
contains_profanity
nextSpawnTime
__input_key_name_set



########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})



########## README.md.txt ##########
# Yean Cat
 Gamemaker Studio 2 Project

## Overview
Yean Cat is a 2D side-scrolling open-world game developed using GameMaker Studio 2. The game features multiple planets, player progression, and rhythm-based elements.

## Features
- Multiplayer functionality
- Dynamic quests and content generation
- Gamepad support for Xbox, PS5, and Switch controllers

## Setup
1. Clone the repository.
2. Open the project in GameMaker Studio 2.
3. Follow the instructions in `docs/setup.md` for additional configuration.

## Usage
- Use the command system to create and manage game content.
- Refer to the in-game help menu for command syntax and examples.

## Contributing
Currently, this project is maintained by a single developer. Contributions are not open at this time.



########## server.py.txt ##########
from flask import Flask
from dotenv import load_dotenv
import os
import threading
from routes.query import query_openai_route
from routes.assistant import assistant_route
from routes.generate_prompt import generate_prompt_route
from routes.update_code import update_code_route

# Initialize the thread lock
thread_lock = threading.Lock()

# Load environment variables from a .env file
load_dotenv()

# Create a Flask application instance
app = Flask(__name__)

# Define a simple route for the home page
@app.route('/')
def home():
    return "Hello, this is the home page of Yean-Cat!"

# Register blueprints for different routes
app.register_blueprint(query_openai_route, url_prefix='/api')
app.register_blueprint(generate_prompt_route, url_prefix='/api')
app.register_blueprint(update_code_route, url_prefix='/api')
app.register_blueprint(assistant_route, url_prefix='/api')

# Main entry point for the application
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() == 'true'
    app.run(debug=debug_mode, host='0.0.0.0', port=port)



########## gitignore.txt ##########
# GameMaker Studio 2 specific files
*.yyc
*.yyp
*.yys
*.yyw
*.yyz
*.yydebug
*.win
*.linux
*.osx
*.ios
*.android

# Temporary files
*.tmp
*.temp

# System files
.DS_Store
Thumbs.db

# Environment variables
.env
code_text/env.txt








########## prompts_backup.txt ##########
########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.





########## tests_backup.txt ##########
########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)






########## Logs_backup.txt ##########
########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.






########## utils_backup.txt ##########
########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)






########## code_text_backup.txt ##########
########## env.txt ##########
OPENAI_API_KEY='sk-proj-9FMlNRVjatGHs2Gu058BT3BlbkFJHK3n2HBzVzzWnwGw3Eqh'
GITHUB_TOKEN='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'
ASSISTANT_API_KEY='asst_7pKEzlqGiYzHbs1v0LscYoxe'
PINECONE_API_KEY='333283cc-9630-4a52-b47d-1898d2a1da77'
PINECONE_INDEX_NAME='yean-cat-git-gpt-index'
GITHUB_USERNAME='JayArnoldProd'


########## update_lists.sh.txt ##########
#!/bin/bash

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Commit and push the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"



########## deploy_all.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## Procfile.txt ##########
web: gunicorn server:app



########## gitattributes.txt ##########
# Auto detect text files and perform LF normalization
* text=auto



########## intro.txt ##########
You are an AI assistant helping with the development of a 2D side-scrolling open world game in the 'survivors' genre using GameMaker Studio 2. The game includes multiplayer functionality, rhythm-based elements, and extensive object interactions. I have created a program that will allow me to communicate with gpt, and automates the process of sending my most recent code (from GitHub) to the AI. You will receive a description of the bug or feature I want you to help me with, along with any code I believe to be relevant for my request. I will also attach a log of my in game console, which I can test features and effectively communicate to you with. Since I am using API integration, sadly you will not remember any of our conversations, which is why you will be receiving so much information. Please make the most educated attempt at bringing me closer to the desired feature or bug fix. If you are not confident enough to solve my issue because you would need to see a specific script that I have not provided you with, then let me know. Please reuse and fix existing code, before adding scripts for things I might already have. Do not assume I have a script for a certain thing if you don't see evidence of it in the code I have provided you.


########## routes_backup.txt ##########
########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})






########## github_backup.txt ##########
########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'






########## prompts_backup.txt ##########
########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.





########## tests_backup.txt ##########
########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)






########## Logs_backup.txt ##########
########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.






########## utils_backup.txt ##########
########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)






########## code_text_backup.txt ##########
########## env.txt ##########
OPENAI_API_KEY='sk-proj-9FMlNRVjatGHs2Gu058BT3BlbkFJHK3n2HBzVzzWnwGw3Eqh'
GITHUB_TOKEN='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'
ASSISTANT_API_KEY='asst_7pKEzlqGiYzHbs1v0LscYoxe'
PINECONE_API_KEY='333283cc-9630-4a52-b47d-1898d2a1da77'
PINECONE_INDEX_NAME='yean-cat-git-gpt-index'
GITHUB_USERNAME='JayArnoldProd'


########## update_lists.sh.txt ##########
#!/bin/bash

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Commit and push the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"



########## deploy_all.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## Procfile.txt ##########
web: gunicorn server:app



########## gitattributes.txt ##########
# Auto detect text files and perform LF normalization
* text=auto



########## intro.txt ##########
You are an AI assistant helping with the development of a 2D side-scrolling open world game in the 'survivors' genre using GameMaker Studio 2. The game includes multiplayer functionality, rhythm-based elements, and extensive object interactions. I have created a program that will allow me to communicate with gpt, and automates the process of sending my most recent code (from GitHub) to the AI. You will receive a description of the bug or feature I want you to help me with, along with any code I believe to be relevant for my request. I will also attach a log of my in game console, which I can test features and effectively communicate to you with. Since I am using API integration, sadly you will not remember any of our conversations, which is why you will be receiving so much information. Please make the most educated attempt at bringing me closer to the desired feature or bug fix. If you are not confident enough to solve my issue because you would need to see a specific script that I have not provided you with, then let me know. Please reuse and fix existing code, before adding scripts for things I might already have. Do not assume I have a script for a certain thing if you don't see evidence of it in the code I have provided you.


########## requirements.txt ##########
blinker==1.8.2
brotlipy==0.7.0
certifi==2022.12.7
cffi==1.15.1
charset-normalizer==2.1.1
click==8.1.7
Flask==3.0.3
gunicorn==22.0.0
idna==3.4
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
numpy==1.24.2
python-dotenv==1.0.1
requests==2.28.1
setuptools==69.2.0
wheel==0.43.0
Werkzeug==3.0.3
pinecone-client==4.1.1


########## format_description.txt ##########
If you are creating a new in-game, executable script, it should start with scr_ and be well-documented. In addition to creating the script with the correct naming format, I also need a line of code that adds the command to the command list.

For Example:
/// @function scr_return_controller()
/// @description Outputs the connected gamepad description or a message if none are connected
function scr_return_controller() {
    if (gamepad_is_connected(0)) {
        var gpad_desc = gamepad_get_description(0);
        handleDebugMessage("Connected gamepad: " + gpad_desc, true);
    } else {
        handleDebugMessage("No gamepad detected.", true);
    }
}

add_command("command name (without scr_, if needs argument(s): ends with '(')", (permission level required), [["string", "real"]] (2D array defining accepted var types for each argument, boolean (whether this command needs at least 1 argument passed));

Permission levels:
0 -> Player
1 -> Moderator
2 -> Developer
3 -> Owner

For Example: 
add_command("set_variable(", 2, [["string"],["string","real"]],true)
add_command("save_game", 0, [[]], false);  // Does not require "(" visually

*Remember this is only needed if you are adding a new command to the game, try and reuse existing scripts as much as possible and let me know if you would need to see a specific script that was not included, but could be helpful in resolving the issue! Remember that you are a 1 time chat interaction and will have no memory of this so If you cant see the solution to the bug or the method to adding the desired feature, then simply reply with what else you need to see in my code.

The game features an in game console which allows players with the required permission to execute code and create new features from within the game. Typing "/" will mean that the player is typing a command. Some commands do not require a "(", for example: /toggle_server . You can create actions by typing /add_action("Name it",Command_name,[100,"example_string"]) and can create macros essentially for commands and will be able to trigger these actions in sequences and events, or possibly controlled by an AI GPT like yourself. This is how It is intended to work, but it is still needing some fixes to be able to handle saving actions for commands that take more than 1 argument, such as /chat_bubble("Text",owner). 


########## runtime.txt ##########
python-3.10.14


########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)



########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)



########## deploy.sh.txt ##########
#!/bin/bash

# Navigate to the project directory
cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Add and commit the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"

# Push to Heroku
git push heroku main



########## pyproject.toml.txt ##########
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"



########## bug_list.json.txt ##########
        [
            {
                "name": "Console Bug",
                "description": "The main bug in my game that needs fixing is that for some reason, typing /add_action(Lvl100,level_up,[100]) works and creates a reusable action named,Lvl100. Typing /execute_action(Lvl100) will level up the player 100 times. The issuse is when I try to create an action with 2 or more arguments, something goes wrong. For example: /add_action(HelloWorld,chat_bubble,[Hello World!,yeancat]) does not work. It says that it created an action, but when I try to execute the action, it throws an error (see cliet logs). I have reason to believe the saving of the actions is where this goes wrong. (scr_add_action)",
                "related_objects": ["obj_Client"],
                "related_scripts": ["execute_command", "scr_add_action", "scr_execute_action", "save_actions", "load_actions", "parse_arguments", "parse_data_types", "handleDebugMessage", "handleCommandWithArgs"],
                "logs": ["SessionLog_45453.16.txt"]
            }
        ]



########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.



########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'



########## planned_features.json.txt ##########
[
    {
        "name": "Sample Feature",
        "description": "This is a sample feature description.",
        "related_objects": ["obj_client", "dondadollar"],
        "related_scripts": ["scr_toggle_server", "scr_list_colors"],
        "logs": ["SessionLog_45450.51.txt"]
    }
]



########## backup.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.


########## command_list.txt ##########
add_action
add_color
betterdirection
calculate_spent
chat_bubble
disable_heartbeat
enable_heartbeat
execute_action
game_end
goto_planet
jump_planet
level_up
list_actions
list_clients
list_colors
list_commands
list_variables
load_game
loadtrack
loadtrack2
name_color
return_controller
save_actions
save_game
save_macros
savetrack
set_my_permission
set_variable
show_gamepad_mapping
show_lines
show_variable
show_wpm
slider_cluster
toggle_debug
toggle_input_display
toggle_log_debug
toggle_server



########## slugignore.txt ##########
.git
*.log
node_modules
__pycache__
*.pyc
.DS_Store
tests
.env
conda-meta
lib/python*/site-packages/conda
lib/python*/site-packages/tensorboardX
lib/python*/site-packages/protobuf
YEAN CAT/sprites
YEAN CAT/sounds
deploy.sh


########## script_list.txt ##########
is_numeric_string
__input_config_gamepads
input_check_opposing_repeat
input_source_mode_get
__input_config_keyboard
calculateAngle
change_input_color
countLinesInString
input_trigger_effect_get_strength
string_last_index_of
scr_toggle_input_display
__input_class_player
input_cursor_coord_space_set
scr_disable_heartbeat
input_cursor_limit_boundary
sort_score
input_binding_scan_time_remaining
input_mouse_y
input_system_import
input_debug_player_input
input_player_get_gamepad
input_players_get_status
input_gamepad_check_released
__input_csv_to_array
input_system_export
parse_data_types
input_profile_copy
input_cursor_elastic_set
FirebaseFirestoreUserFunctions
__input_class_combo_state
adjustAngle
input_hotswap_params_set
input_profile_get_array
FirebaseREST_firestore_value
concat
__input_string_contains
input_mouse_x
input_ignore_key_add
__input_define_gamepad_types
input_cursor_speed_set
FirebaseFirestorePaths
FriebaseREST_Firestore_urlUpdateMask
input_check_opposing
input_vibrate_set_strength
input_verb_get_icon
__input_source_relinquish
__input_error
input_check_long
FirebaseREST_Firestore_path_isCollection
input_keyboard_virtual_show
input_system_reset
scr_loadtrack2
input_trigger_effect_get_state
logChatMessage
input_binding_mouse_wheel_down
input_player_connected_count
__input_config_external_data
__input_get_previous_time
input_combo_params_set_side_on
FirebaseREST_Firestore_collection_decode
input_binding_scan_start
input_mouse_capture_get
input_cursor_limit_remove
input_player_connected
update_chat_input_visuals
input_source_is_available
__input_config_profiles
input_mouse_check
input_binding_get_icon
input_check_long_pressed
input_player_active_set
currentSyncedTime
input_is_analogue
input_vibrate_constant
__input_restart_get
input_mouse_wheel_up
input_binding_get_name
input_source_share
__input_restart
scr_save_game
scr_return_controller
syncTimeWithServer
scr_game_end
__input_gamepad_set_blacklist
__input_gamepad_tester_init
__input_class_trigger_effect_vibration
input_binding_threshold_get
drawChatMessages
input_profile_destroy
input_combo_get_new_phase
scr_show_lines
input_accessibility_global_cooldown_get
seconds_to_time
input_virtual_destroy_all
input_cursor_translate
__input_gamepad_tester_build_gui
__input_class_icon_category
input_binding_set
__input_ensure_unique_verb_name
__input_config_verbs
__input_wrap_underflow
input_verb_groups_get
__input_class_virtual
FirebaseFirestore_operationFromSymbol
input_axis_threshold_get
input_player_ghost_set
input_mouse_wheel_down
input_verb_group_is_active
input_check_repeat
input_window_has_focus
__input_class_verb_state
input_gamepad_value
input_combo_get_charge
last_key_is_valid_character
input_clear_momentary
input_source_add
input_color_reset
__input_gamepad_guid_parse
input_icons
input_profile_verify
input_source_detect_input
input_cursor_inverted_set
input_combo_create
input_source_get_array
input_color_get
__input_mouse_button
input_mouse_check_released
input_debug_all_input
input_check_double_released
__input_gamepad_tester_destroy_gui
calculatePlayerStats
input_player_get_invalid_gamepad_bindings
save_actions
seconds_to_formatted_string
check_permission
input_binding_scan_params_get
input_binding_virtual_button
scr_set_my_permission
scr_list_variables
formatChatInput
input_profile_exists
__input_hotswap_tick
__input_load_type_csv
input_check_press_most_recent
input_binding_swap
input_player_using_keyboard
scr_show_gamepad_mapping
input_cursor_gyro_enabled_set
input_accessibility_verb_toggle_set
__input_key_get_name
input_player_disconnect
__input_gamepad_set_mapping
player_data_needs_update
__input_config_icons
input_binding_mouse_button
__input_config_general
__input_gamepad_find_in_sdl2_database
input_mouse_moved
scr_enable_heartbeat
__input_system_tick
execute_command
scr_list_clients
input_max_value
input_player_reset
__input_class_trigger_effect_off
input_trigger_effect_set_pause
__input_initialize
input_verb_consume
scr_execute_action
input_cursor_mouse_enabled_get
scr_chat_bubble
input_icons_keyboard_and_mouse
scr_goto_planet
scr_toggle_server
scr_calculate_spent
__input_keyboard_key
input_source_clear
scr_savetrack
input_mouse_coord_space_set
input_player_gamepad_type_override_get
__input_multiplayer_assignment_tick
input_check_quick_pressed_2d
input_gamepad_delta
input_distance
input_binding_get_source_type
input_profile_reset_bindings
FirebaseREST_Firestore_jsonDecode
input_trigger_effect_set_strength
FirebaseREST_parse
input_gamepad_check_pressed
scr_betterdirection
input_player_import
input_icon_not_a_binding
instance_nearest_notme
parse_arguments
input_gamepads_get_status
input_profile_set
input_combo_get_phase
FirebaseREST_firestore_fieldReference
FirebaseREST_Firestore_getURL
input_player_export
input_keyboard_check_pressed
input_binding_scan_abort
input_join_params_set
input_virtual_create
input_player_swap
input_trigger_effect_get_pause
FirebaseREST_asyncCall_Firestore
updateWPM
input_verb_group_get_verbs
FirebaseREST_HTTP_Failed_Firestore
__input_player_apply_trigger_effects
input_combo_get_direction
input_vibrate_get_strength
input_gamepad_is_connected
input_gamepad_tester_set
input_players_using_source
input_accessibility_global_toggle_set
draw_text_bold
input_keyboard_check
input_check
input_source_detect_new
input_binding_gamepad_axis
input_source_set
input_cursor_elastic_remove
input_binding_mouse_wheel_up
input_combo_get_phase_count
input_accessibility_verb_cooldown_get
__input_load_sdl2_from_string
scr_toggle_log_debug
input_player_using_mouse
add_variable
update_game_state
string_word_count
json_compare
__input_axis_is_directional
__input_config_mouse
input_mouse_in_bounds
input_cursor_gyro_params_set
scr_save_macros
input_binding_gamepad_set
FirebaseListenerUserFunctions_Firestore
__input_class_combo_definition
input_cursor_limit_get
instance_nearest_notme2
scr_add_action
scr_jump_planet
__input_config_verb_behaviour
FirebaseREST_asyncFunction_Firestore
FirebaseREST_Firestore_jsonEncode
input_player_verify
input_held_time
input_gamepad_check
string_trim_right
__input_config_combos
input_binding_get
__input_config_vibration
input_profile_auto
input_check_quick_pressed
handleDebugMessage
input_binding_remove
input_gamepad_get_type
scr_toggle_debug
string_remove_between
input_axis_threshold_set
check_control_type
input_player_ghost_get
__input_load_sdl2_from_buffer_legacy
input_check_double
input_combo_params_get
draw_rectangle_outlined
input_mouse_dx
__input_gamepad_value_internal
scr_load_game
input_binding_key
add_command
__input_key_is_ignored
input_check_long_released
level_up
string_is_real
check_tasks
string_contains
FirebaseFirestoreMainFunctions
input_accessibility_global_cooldown_set
scr_set_variable
input_binding_scan_params_clear
input_check_double_pressed
FirebaseREST_Firestore_collection_query_decode
input_binding_threshold_set
__input_config_multiplayer
draw_text_bold_ext2
input_mouse_dy
appendAndWrap
input_virtual_debug_draw
input_binding_empty
input_player_active_get
handleCommandWithArgs
__input_gamepad_set_vid_pid
scr_level_up
load_actions
__input_snap_to_json
adjust_pitch
is_valid_email
__input_class_gamepad_mapping
scr_slider_cluster
__input_gamepad_stop_trigger_effects
scr_name_color
get_longest_word_width
input_chord_create
input_mouse_capture_set
__input_macros
draw_text_bold_ext
input_cursor_speed_get
input_game_has_focus
input_hotswap_params_get
forceLineBreakAtMaxWidth
FirebasePathsUserFunctions
input_radial_sector
__input_class_source
__input_binding_get_label
input_led_pattern_get
__input_gamepad_reset_color
input_x
FirebaseREST_firestore_cursor
__input_class_trigger_effect_weapon
scr_save_actions
input_cursor_elastic_get
scr_show_variable
input_gamepad_is_any_connected
input_cursor_set
input_check_pressed
handleNetworkData
FirebaseREST_firestore_value_json
get_delta_time
input_combo_reset
__input_class_gamepad_motion
input_y
__input_class_vibration_pulse
input_gamepad_get_map
__input_class_vibration_constant
__input_class_vibration_adsr
wrap_text
input_source_mode_set
input_trigger_effect_vibration
scr_list_colors
checkAndSpawnEnemies
input_cursor_coord_space_get
input_binding_scan_in_progress
__input_player_tick_sources
input_source_using
__input_class_vibration_curve
scr_show_wpm
input_keyboard_virtual_hide
__input_global
input_mouse_check_pressed
input_gamepad_is_axis
input_player_using_touch
__input_class_chord_definition
input_vibrate_pulse
input_trigger_effect_feedback
input_cursor_limit_circle
input_accessibility_verb_cooldown_set
input_direction
__input_config_touch
input_ignore_key_remove
input_cursor_gyro_params_get
input_binding_gamepad_get
check_permission_command
input_vibrate_curve
FirebaseREST_HTTP_Success_Firestore
__input_class_cursor
input_verb_group_active
__input_config_verb_groups
input_held_time_released
input_value
input_icons_gamepad
input_trigger_effect_weapon
FirebaseREST_Firestore_collection_compare
getMessageHeight
input_player_using_gamepad
input_vibrate_stop
input_cursor_limit_aabb
__input_class_gamepad
input_motion_data_get
input_gamepad_tester_get
input_accessibility_global_toggle_get
__input_steam_type_set
__input_gamepad_set_description
input_profile_export
input_profile_get
input_value_is_binding
__input_exception_handler
array_to_string
input_vibrate_set_pause
FirebaseREST_Firestore_headerToken
__input_window_changed
__input_trace_loud
__input_gamepad_type_swap_ab
scr_loadtrack
input_player_get_gamepad_type
angle_distance
input_join_params_get
__input_config_hotswap
input_gamepad_map_contains
input_trigger_effect_off
__input_load_blacklist_csv
input_verb_get_group
input_mouse_coord_space_get
input_player_gamepad_type_override_set
__input_trace
__input_clear_all
shortestAngularDistance
input_keyboard_check_released
shortestAngularDirection
input_check_opposing_pressed
__input_virtual_player_set
__input_gamepad_tester_tick
input_profile_import
__input_validate_macros
input_join_is_finished
FirebaseREST_Firestore_path_isDocument
__input_transform_coordinate
__input_finalize_default_profiles
input_profile_create
__input_class_chord_state
drawTextWithOutline
input_vibrate_get_pause
input_cursor_mouse_enabled_set
input_binding_is_valid
input_cursor_dy
__input_class_binding
update_audio_pitch
draw_healthbar_border
input_system_verify
input_verb_set
input_combo_params_reset
input_icon_touch
input_binding_test_collisions
__input_gamepad_set_type
input_gamepad_get_description
scr_add_color
parse_action_parameters
input_cursor_gyro_enabled_get
scr_resolution
scr_list_commands
input_accessibility_verb_toggle_get
__input_get_time
scr_list_actions
are_arguments_valid
calculate_color_distance
input_cursor_y
input_binding_get_verbs
load_responses
input_gamepad_constant_get_name
input_binding_scan_params_set
input_is_virtual
input_player_copy
input_cursor_dx
input_xy
updateLongestMessage
draw_text_kern
input_combo_params_set_top_down
__input_steam_handles_changed
input_cursor_x
__input_class_trigger_effect_feedback
__input_load_sdl2_from_string_internal
__input_load_sdl2_from_file
debug_action_details
input_cursor_inverted_get
__input_finalize_verb_groups
input_color_set
input_binding_gamepad_button
input_icon_empty
check_gamepad_input
command_requires_arguments
__input_config_cursor
input_check_released
input_vibrate_adsr
input_binding_set_safe
contains_profanity
nextSpawnTime
__input_key_name_set



########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})



########## README.md.txt ##########
# Yean Cat
 Gamemaker Studio 2 Project

## Overview
Yean Cat is a 2D side-scrolling open-world game developed using GameMaker Studio 2. The game features multiple planets, player progression, and rhythm-based elements.

## Features
- Multiplayer functionality
- Dynamic quests and content generation
- Gamepad support for Xbox, PS5, and Switch controllers

## Setup
1. Clone the repository.
2. Open the project in GameMaker Studio 2.
3. Follow the instructions in `docs/setup.md` for additional configuration.

## Usage
- Use the command system to create and manage game content.
- Refer to the in-game help menu for command syntax and examples.

## Contributing
Currently, this project is maintained by a single developer. Contributions are not open at this time.



########## server.py.txt ##########
from flask import Flask
from dotenv import load_dotenv
import os
import threading
from routes.query import query_openai_route
from routes.assistant import assistant_route
from routes.generate_prompt import generate_prompt_route
from routes.update_code import update_code_route

# Initialize the thread lock
thread_lock = threading.Lock()

# Load environment variables from a .env file
load_dotenv()

# Create a Flask application instance
app = Flask(__name__)

# Define a simple route for the home page
@app.route('/')
def home():
    return "Hello, this is the home page of Yean-Cat!"

# Register blueprints for different routes
app.register_blueprint(query_openai_route, url_prefix='/api')
app.register_blueprint(generate_prompt_route, url_prefix='/api')
app.register_blueprint(update_code_route, url_prefix='/api')
app.register_blueprint(assistant_route, url_prefix='/api')

# Main entry point for the application
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() == 'true'
    app.run(debug=debug_mode, host='0.0.0.0', port=port)



########## gitignore.txt ##########
# GameMaker Studio 2 specific files
*.yyc
*.yyp
*.yys
*.yyw
*.yyz
*.yydebug
*.win
*.linux
*.osx
*.ios
*.android

# Temporary files
*.tmp
*.temp

# System files
.DS_Store
Thumbs.db

# Environment variables
.env
code_text/env.txt





########## requirements.txt ##########
blinker==1.8.2
brotlipy==0.7.0
certifi==2022.12.7
cffi==1.15.1
charset-normalizer==2.1.1
click==8.1.7
Flask==3.0.3
gunicorn==22.0.0
idna==3.4
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
numpy==1.24.2
python-dotenv==1.0.1
requests==2.28.1
setuptools==69.2.0
wheel==0.43.0
Werkzeug==3.0.3
pinecone-client==4.1.1


########## format_description.txt ##########
If you are creating a new in-game, executable script, it should start with scr_ and be well-documented. In addition to creating the script with the correct naming format, I also need a line of code that adds the command to the command list.

For Example:
/// @function scr_return_controller()
/// @description Outputs the connected gamepad description or a message if none are connected
function scr_return_controller() {
    if (gamepad_is_connected(0)) {
        var gpad_desc = gamepad_get_description(0);
        handleDebugMessage("Connected gamepad: " + gpad_desc, true);
    } else {
        handleDebugMessage("No gamepad detected.", true);
    }
}

add_command("command name (without scr_, if needs argument(s): ends with '(')", (permission level required), [["string", "real"]] (2D array defining accepted var types for each argument, boolean (whether this command needs at least 1 argument passed));

Permission levels:
0 -> Player
1 -> Moderator
2 -> Developer
3 -> Owner

For Example: 
add_command("set_variable(", 2, [["string"],["string","real"]],true)
add_command("save_game", 0, [[]], false);  // Does not require "(" visually

*Remember this is only needed if you are adding a new command to the game, try and reuse existing scripts as much as possible and let me know if you would need to see a specific script that was not included, but could be helpful in resolving the issue! Remember that you are a 1 time chat interaction and will have no memory of this so If you cant see the solution to the bug or the method to adding the desired feature, then simply reply with what else you need to see in my code.

The game features an in game console which allows players with the required permission to execute code and create new features from within the game. Typing "/" will mean that the player is typing a command. Some commands do not require a "(", for example: /toggle_server . You can create actions by typing /add_action("Name it",Command_name,[100,"example_string"]) and can create macros essentially for commands and will be able to trigger these actions in sequences and events, or possibly controlled by an AI GPT like yourself. This is how It is intended to work, but it is still needing some fixes to be able to handle saving actions for commands that take more than 1 argument, such as /chat_bubble("Text",owner). 


########## runtime.txt ##########
python-3.10.14


########## test_api_endpoints.py.txt ##########
# tests/test_api_endpoints.py
import requests
import os

BASE_URL = "https://yean-cat-git-gpt-dd907a6ae83f.herokuapp.com"

# Function to print response content
def print_response(response):
    try:
        print("Response JSON:", response.json())
    except requests.exceptions.JSONDecodeError:
        print("Response Content:", response.content)

# Pinecone Initialization Test
response = requests.post(f"{BASE_URL}/api/query", json={
    "prompt_name": "test_prompt",
    "input_text": "Initialize Pinecone"
})
print("Pinecone Initialization Test:")
print_response(response)

# GPT Connection Test
response = requests.post(f"{BASE_URL}/api/generate_prompt", json={
    "save_name": "test_save",
    "input_text": "Test GPT connection"
})
print("GPT Connection Test:")
print_response(response)

# Update Code Test
response = requests.post(f"{BASE_URL}/api/update_code", json={
    "save_name": "test_save",
    "code_changes": [
        {
            "file_path": "test.py",
            "changes": "print('Hello World')"
        }
    ]
})
print("Update Code Test:")
print_response(response)

# Assistant Test
response = requests.post(f"{BASE_URL}/api/assistant", json={
    "query": "Test assistant",
    "context": "Testing the assistant endpoint."
}, headers={
    "Authorization": f"Bearer {os.getenv('ASSISTANT_API_KEY')}"
})
print("Assistant Test:")
print_response(response)



########## openai_operations.py.txt ##########
import os
import requests

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

def query_openai(prompt, model='gpt-4', retries=3):
    for i in range(retries):
        try:
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers={'Authorization': f'Bearer {OPENAI_API_KEY}'},
                json={
                    'model': model,
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': 1000,
                    'temperature': 0.5,
                }
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if response.status_code == 429:  # Too Many Requests
                retry_after = int(response.headers.get("Retry-After", 10))  # default to 10 seconds
                time.sleep(retry_after + random.uniform(0, 1))  # adding some jitter
            else:
                raise e
    raise Exception("Max retries exceeded")



########## pinecone_operations.py.txt ##########
import os
from pinecone import Pinecone, ServerlessSpec

def init_pinecone_index(index_name):
    api_key = os.getenv("PINECONE_API_KEY")
    pc = Pinecone(api_key=api_key)
    
    if index_name not in pc.list_indexes().names():
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric='euclidean',
            spec=ServerlessSpec(
                cloud='aws',
                region='us-west-2'
            )
        )
    return pc

def upsert_vectors_to_pinecone(vectors):
    index_name = os.getenv("PINECONE_INDEX_NAME")
    api_key = os.getenv("PINECONE_API_KEY")
    
    pc = Pinecone(api_key=api_key)
    index = pc.Index(index_name)
    
    # Assuming vectors is a list of tuples (id, vector)
    index.upsert(vectors)



########## file_operations.py.txt ##########
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(file_path, content):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(content)



########## deploy.sh.txt ##########
#!/bin/bash

# Navigate to the project directory
cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat

# Generate a list of all scripts
find "YEAN CAT/scripts" -name "*.gml" -exec basename {} .gml \; > script_list.txt

# Generate a list of all commands starting with scr_ and remove the scr_ prefix
grep -r "function scr_" "YEAN CAT/scripts" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > command_list.txt

# Add and commit the updated lists
git add script_list.txt command_list.txt
git commit -m "Update script and command lists"

# Push to Heroku
git push heroku main



########## pyproject.toml.txt ##########
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"



########## bug_list.json.txt ##########
        [
            {
                "name": "Console Bug",
                "description": "The main bug in my game that needs fixing is that for some reason, typing /add_action(Lvl100,level_up,[100]) works and creates a reusable action named,Lvl100. Typing /execute_action(Lvl100) will level up the player 100 times. The issuse is when I try to create an action with 2 or more arguments, something goes wrong. For example: /add_action(HelloWorld,chat_bubble,[Hello World!,yeancat]) does not work. It says that it created an action, but when I try to execute the action, it throws an error (see cliet logs). I have reason to believe the saving of the actions is where this goes wrong. (scr_add_action)",
                "related_objects": ["obj_Client"],
                "related_scripts": ["execute_command", "scr_add_action", "scr_execute_action", "save_actions", "load_actions", "parse_arguments", "parse_data_types", "handleDebugMessage", "handleCommandWithArgs"],
                "logs": ["SessionLog_45453.16.txt"]
            }
        ]



########## SessionLog_45453.16.txt ##########
06/09/24 22:53:39: Actions.txt not found. Starting with an empty actions map.
06/09/24 22:54:26: [Jay Arnold] Hello World!
06/09/24 22:54:37: [Jay Arnold] I will now demonstrate how the add action is not working
06/09/24 22:54:59: Action 'Lvl100' added successfully.
06/09/24 22:55:08: Executing action: level_up(100)
06/09/24 22:55:08: Level up initiated with goal: 100
06/09/24 22:55:18: [Jay Arnold] see? that works beautifully
06/09/24 22:55:22: Actions: Lvl100, 
06/09/24 22:55:37: [Jay Arnold] now what if i try /chat_bubble
06/09/24 22:55:50: Chat Bubble Created. Following 'yeancat' with text: 'Hello World!'
06/09/24 22:56:08: [Jay Arnold] the command works when executing normally, lets try and make it 
into an action
06/09/24 22:56:50: Action 'HelloWorld' added successfully.
06/09/24 22:56:54: Actions: Lvl100, HelloWorld, 
06/09/24 22:56:58: Actions saved successfully to Actions.txt.
06/09/24 22:57:15: [Jay Arnold] i will insert what the Actions.txt contains here:

Lvl100,level_up,[ 100 ]
HelloWorld,chat_bubble,[ ""Hello World!" ] // it appears to not have saved the second argument!

06/09/24 22:57:39: Executing action: chat_bubble("Hello World!)
06/09/24 22:57:39: Error: Owner object 'undefined' not found
06/09/24 22:57:52: [Jay Arnold] See! an error!
06/09/24 22:59:08: [Jay Arnold] I will now end the test. but first heres a list of all my commands i can
 use so far. We just need to fix this bug involving the actions and then
 we can make many cool systems that use our action system.
06/09/24 22:59:15: Commands: add_action(, chat_bubble(, disable_heartbeat, 
06/09/24 22:59:15: enable_heartbeat, execute_action(, game_end(, goto_planet(, 
06/09/24 22:59:15: jump_planet(, level_up(, list_actions, list_clients, list_commands, 
06/09/24 22:59:15: list_variables, return_controller, save_actions, save_game, 
06/09/24 22:59:15: save_macros, set_my_permission(, set_variable(, show_gamepad_mapping, 
06/09/24 22:59:15: show_lines(, show_variable(, show_wpm, toggle_debug, 
06/09/24 22:59:15: toggle_input_display, toggle_log_debug, toggle_server
06/09/24 22:59:30: Saved Game
06/09/24 22:59:30: Game saved and ending.



########## main.yml.txt ##########
name: CI/CD

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flask requests python-dotenv

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add commands to run your tests
        echo "Tests completed."

    - name: Debug information
      run: |
        echo "Debugging information:"
        echo "PWD: $(pwd)"
        echo "Files in current directory:"
        ls -la

    - name: Analyze code with GPT-4
      run: |
        echo "Running code analysis..."
        echo '{"prompt": "Analyze the following code: def add(a, b): return a + b"}'



########## planned_features.json.txt ##########
[
    {
        "name": "Sample Feature",
        "description": "This is a sample feature description.",
        "related_objects": ["obj_client", "dondadollar"],
        "related_scripts": ["scr_toggle_server", "scr_list_colors"],
        "logs": ["SessionLog_45450.51.txt"]
    }
]



########## backup.sh.txt ##########
#!/bin/bash
# deploy_all.sh

echo "Starting deployment script..."

# Step 1: Delete all files in the code_text directory
echo "Deleting all files in the code_text directory..."
rm -rf code_text/*
echo "Files deleted."

# Step 2: Define backup directory
BACKUP_DIR="code_text"
mkdir -p $BACKUP_DIR

# Step 3: Function to copy files while preserving directory structure
copy_files() {
  for file in "$@"; do
    dest="$BACKUP_DIR/${file#./}"
    mkdir -p "$(dirname "$dest")"
    echo "Copying $file to $dest"
    if [[ $file != *.txt ]]; then
      cp "$file" "$dest.txt"
      mv "$dest.txt" "${dest#.}.txt"  # Remove leading dot to make the file visible and add .txt extension
    else
      cp "$file" "$dest"
      mv "$dest" "${dest#.}"  # Remove leading dot to make the file visible
    fi
  done
}

# Step 4: Function to unhide directories and files within them
unhide_directories() {
  find $BACKUP_DIR -type d -name ".*" | while read hidden_dir; do
    mv "$hidden_dir" "$(dirname "$hidden_dir")/$(basename "$hidden_dir" | sed 's/^\.//')"
  done
}

# Step 5: Find all relevant files in the root directory and subdirectories
all_files=$(find . -type f ! -path "./$BACKUP_DIR/*" ! -path "./.git/*" ! -path "./YEAN CAT/*" ! -name ".DS_Store")

# Debugging information
echo "All files to be backed up:"
echo "$all_files"

# Step 6: Copy files to backup directory
copy_files $all_files

# Step 7: Unhide .txt files if they were hidden originally
find $BACKUP_DIR -name ".*.txt" | while read hidden_file; do
  mv "$hidden_file" "$(dirname "$hidden_file")/$(basename "$hidden_file" | sed 's/^\.//')"
done

# Step 8: Unhide hidden directories
unhide_directories

# Step 9: Create the folder backups folder
FOLDER_BACKUPS="folder_backups"
mkdir -p $FOLDER_BACKUPS

# Step 10: Function to create a master backup file for a folder
create_master_backup() {
    local folder=$1
    local output_file=$FOLDER_BACKUPS/$(basename $folder)_backup.txt

    # Empty the output file if it already exists
    > $output_file

    echo "Creating master backup for $folder at $output_file"
    # Iterate over all .txt files in the folder
    for file in $(find $folder -type f -name "*.txt"); do
        if [ -f "$file" ]; then
            echo "########## $(basename $file) ##########" >> $output_file
            cat "$file" >> $output_file
            echo -e "\n\n" >> $output_file
            echo "Added $file to $output_file"
        fi
    done
}

# Step 11: Create master backup files for each subfolder in code_text
for folder in $(find $BACKUP_DIR -mindepth 1 -maxdepth 1 -type d); do
    create_master_backup $folder
done

# Step 12: Create a master backup for the top-level .txt files
create_master_backup $BACKUP_DIR

# Step 13: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Step 14: Deploy to Heroku
echo "Deploying to Heroku..."
heroku git:remote -a yean-cat-git-gpt
git push heroku main

echo "Backup and deployment completed successfully!"



########## test_prompt.txt ##########
Introduction:
This prompt is designed to diagnose and provide a solution for a bug in the console of the Yean-Cat project.

Bug Description:
The console is experiencing a bug where it fails to execute certain commands correctly. Specifically, when the 'spawn_enemy' command is issued, the game does not spawn an enemy as expected. This issue occurs intermittently and seems to be related to the game's state or the sequence of previous commands.

Steps to Reproduce:
1. Start the game.
2. Open the console.
3. Enter the 'spawn_enemy' command.
4. Observe that no enemy is spawned, or an error message is displayed.

Relevant Scripts:
Script 1: console_command.gml

// Example script content for console_command.gml
if (command == "spawn_enemy") {
    if (game_state == "running") {
        instance_create_layer(x, y, "Enemies", obj_enemy);
    } else {
        show_debug_message("Cannot spawn enemy: Game is not in running state.");
    }
}

// Example script content for obj_enemy.gml
event_inherited();
hp = 100;
speed = 3;

// Example content for obj_console
if (keyboard_check_pressed(vk_enter)) {
    execute_console_command();
}
Logs:
No relevant logs for this bug.


########## command_list.txt ##########
add_action
add_color
betterdirection
calculate_spent
chat_bubble
disable_heartbeat
enable_heartbeat
execute_action
game_end
goto_planet
jump_planet
level_up
list_actions
list_clients
list_colors
list_commands
list_variables
load_game
loadtrack
loadtrack2
name_color
return_controller
save_actions
save_game
save_macros
savetrack
set_my_permission
set_variable
show_gamepad_mapping
show_lines
show_variable
show_wpm
slider_cluster
toggle_debug
toggle_input_display
toggle_log_debug
toggle_server



########## slugignore.txt ##########
.git
*.log
node_modules
__pycache__
*.pyc
.DS_Store
tests
.env
conda-meta
lib/python*/site-packages/conda
lib/python*/site-packages/tensorboardX
lib/python*/site-packages/protobuf
YEAN CAT/sprites
YEAN CAT/sounds
deploy.sh


########## script_list.txt ##########
is_numeric_string
__input_config_gamepads
input_check_opposing_repeat
input_source_mode_get
__input_config_keyboard
calculateAngle
change_input_color
countLinesInString
input_trigger_effect_get_strength
string_last_index_of
scr_toggle_input_display
__input_class_player
input_cursor_coord_space_set
scr_disable_heartbeat
input_cursor_limit_boundary
sort_score
input_binding_scan_time_remaining
input_mouse_y
input_system_import
input_debug_player_input
input_player_get_gamepad
input_players_get_status
input_gamepad_check_released
__input_csv_to_array
input_system_export
parse_data_types
input_profile_copy
input_cursor_elastic_set
FirebaseFirestoreUserFunctions
__input_class_combo_state
adjustAngle
input_hotswap_params_set
input_profile_get_array
FirebaseREST_firestore_value
concat
__input_string_contains
input_mouse_x
input_ignore_key_add
__input_define_gamepad_types
input_cursor_speed_set
FirebaseFirestorePaths
FriebaseREST_Firestore_urlUpdateMask
input_check_opposing
input_vibrate_set_strength
input_verb_get_icon
__input_source_relinquish
__input_error
input_check_long
FirebaseREST_Firestore_path_isCollection
input_keyboard_virtual_show
input_system_reset
scr_loadtrack2
input_trigger_effect_get_state
logChatMessage
input_binding_mouse_wheel_down
input_player_connected_count
__input_config_external_data
__input_get_previous_time
input_combo_params_set_side_on
FirebaseREST_Firestore_collection_decode
input_binding_scan_start
input_mouse_capture_get
input_cursor_limit_remove
input_player_connected
update_chat_input_visuals
input_source_is_available
__input_config_profiles
input_mouse_check
input_binding_get_icon
input_check_long_pressed
input_player_active_set
currentSyncedTime
input_is_analogue
input_vibrate_constant
__input_restart_get
input_mouse_wheel_up
input_binding_get_name
input_source_share
__input_restart
scr_save_game
scr_return_controller
syncTimeWithServer
scr_game_end
__input_gamepad_set_blacklist
__input_gamepad_tester_init
__input_class_trigger_effect_vibration
input_binding_threshold_get
drawChatMessages
input_profile_destroy
input_combo_get_new_phase
scr_show_lines
input_accessibility_global_cooldown_get
seconds_to_time
input_virtual_destroy_all
input_cursor_translate
__input_gamepad_tester_build_gui
__input_class_icon_category
input_binding_set
__input_ensure_unique_verb_name
__input_config_verbs
__input_wrap_underflow
input_verb_groups_get
__input_class_virtual
FirebaseFirestore_operationFromSymbol
input_axis_threshold_get
input_player_ghost_set
input_mouse_wheel_down
input_verb_group_is_active
input_check_repeat
input_window_has_focus
__input_class_verb_state
input_gamepad_value
input_combo_get_charge
last_key_is_valid_character
input_clear_momentary
input_source_add
input_color_reset
__input_gamepad_guid_parse
input_icons
input_profile_verify
input_source_detect_input
input_cursor_inverted_set
input_combo_create
input_source_get_array
input_color_get
__input_mouse_button
input_mouse_check_released
input_debug_all_input
input_check_double_released
__input_gamepad_tester_destroy_gui
calculatePlayerStats
input_player_get_invalid_gamepad_bindings
save_actions
seconds_to_formatted_string
check_permission
input_binding_scan_params_get
input_binding_virtual_button
scr_set_my_permission
scr_list_variables
formatChatInput
input_profile_exists
__input_hotswap_tick
__input_load_type_csv
input_check_press_most_recent
input_binding_swap
input_player_using_keyboard
scr_show_gamepad_mapping
input_cursor_gyro_enabled_set
input_accessibility_verb_toggle_set
__input_key_get_name
input_player_disconnect
__input_gamepad_set_mapping
player_data_needs_update
__input_config_icons
input_binding_mouse_button
__input_config_general
__input_gamepad_find_in_sdl2_database
input_mouse_moved
scr_enable_heartbeat
__input_system_tick
execute_command
scr_list_clients
input_max_value
input_player_reset
__input_class_trigger_effect_off
input_trigger_effect_set_pause
__input_initialize
input_verb_consume
scr_execute_action
input_cursor_mouse_enabled_get
scr_chat_bubble
input_icons_keyboard_and_mouse
scr_goto_planet
scr_toggle_server
scr_calculate_spent
__input_keyboard_key
input_source_clear
scr_savetrack
input_mouse_coord_space_set
input_player_gamepad_type_override_get
__input_multiplayer_assignment_tick
input_check_quick_pressed_2d
input_gamepad_delta
input_distance
input_binding_get_source_type
input_profile_reset_bindings
FirebaseREST_Firestore_jsonDecode
input_trigger_effect_set_strength
FirebaseREST_parse
input_gamepad_check_pressed
scr_betterdirection
input_player_import
input_icon_not_a_binding
instance_nearest_notme
parse_arguments
input_gamepads_get_status
input_profile_set
input_combo_get_phase
FirebaseREST_firestore_fieldReference
FirebaseREST_Firestore_getURL
input_player_export
input_keyboard_check_pressed
input_binding_scan_abort
input_join_params_set
input_virtual_create
input_player_swap
input_trigger_effect_get_pause
FirebaseREST_asyncCall_Firestore
updateWPM
input_verb_group_get_verbs
FirebaseREST_HTTP_Failed_Firestore
__input_player_apply_trigger_effects
input_combo_get_direction
input_vibrate_get_strength
input_gamepad_is_connected
input_gamepad_tester_set
input_players_using_source
input_accessibility_global_toggle_set
draw_text_bold
input_keyboard_check
input_check
input_source_detect_new
input_binding_gamepad_axis
input_source_set
input_cursor_elastic_remove
input_binding_mouse_wheel_up
input_combo_get_phase_count
input_accessibility_verb_cooldown_get
__input_load_sdl2_from_string
scr_toggle_log_debug
input_player_using_mouse
add_variable
update_game_state
string_word_count
json_compare
__input_axis_is_directional
__input_config_mouse
input_mouse_in_bounds
input_cursor_gyro_params_set
scr_save_macros
input_binding_gamepad_set
FirebaseListenerUserFunctions_Firestore
__input_class_combo_definition
input_cursor_limit_get
instance_nearest_notme2
scr_add_action
scr_jump_planet
__input_config_verb_behaviour
FirebaseREST_asyncFunction_Firestore
FirebaseREST_Firestore_jsonEncode
input_player_verify
input_held_time
input_gamepad_check
string_trim_right
__input_config_combos
input_binding_get
__input_config_vibration
input_profile_auto
input_check_quick_pressed
handleDebugMessage
input_binding_remove
input_gamepad_get_type
scr_toggle_debug
string_remove_between
input_axis_threshold_set
check_control_type
input_player_ghost_get
__input_load_sdl2_from_buffer_legacy
input_check_double
input_combo_params_get
draw_rectangle_outlined
input_mouse_dx
__input_gamepad_value_internal
scr_load_game
input_binding_key
add_command
__input_key_is_ignored
input_check_long_released
level_up
string_is_real
check_tasks
string_contains
FirebaseFirestoreMainFunctions
input_accessibility_global_cooldown_set
scr_set_variable
input_binding_scan_params_clear
input_check_double_pressed
FirebaseREST_Firestore_collection_query_decode
input_binding_threshold_set
__input_config_multiplayer
draw_text_bold_ext2
input_mouse_dy
appendAndWrap
input_virtual_debug_draw
input_binding_empty
input_player_active_get
handleCommandWithArgs
__input_gamepad_set_vid_pid
scr_level_up
load_actions
__input_snap_to_json
adjust_pitch
is_valid_email
__input_class_gamepad_mapping
scr_slider_cluster
__input_gamepad_stop_trigger_effects
scr_name_color
get_longest_word_width
input_chord_create
input_mouse_capture_set
__input_macros
draw_text_bold_ext
input_cursor_speed_get
input_game_has_focus
input_hotswap_params_get
forceLineBreakAtMaxWidth
FirebasePathsUserFunctions
input_radial_sector
__input_class_source
__input_binding_get_label
input_led_pattern_get
__input_gamepad_reset_color
input_x
FirebaseREST_firestore_cursor
__input_class_trigger_effect_weapon
scr_save_actions
input_cursor_elastic_get
scr_show_variable
input_gamepad_is_any_connected
input_cursor_set
input_check_pressed
handleNetworkData
FirebaseREST_firestore_value_json
get_delta_time
input_combo_reset
__input_class_gamepad_motion
input_y
__input_class_vibration_pulse
input_gamepad_get_map
__input_class_vibration_constant
__input_class_vibration_adsr
wrap_text
input_source_mode_set
input_trigger_effect_vibration
scr_list_colors
checkAndSpawnEnemies
input_cursor_coord_space_get
input_binding_scan_in_progress
__input_player_tick_sources
input_source_using
__input_class_vibration_curve
scr_show_wpm
input_keyboard_virtual_hide
__input_global
input_mouse_check_pressed
input_gamepad_is_axis
input_player_using_touch
__input_class_chord_definition
input_vibrate_pulse
input_trigger_effect_feedback
input_cursor_limit_circle
input_accessibility_verb_cooldown_set
input_direction
__input_config_touch
input_ignore_key_remove
input_cursor_gyro_params_get
input_binding_gamepad_get
check_permission_command
input_vibrate_curve
FirebaseREST_HTTP_Success_Firestore
__input_class_cursor
input_verb_group_active
__input_config_verb_groups
input_held_time_released
input_value
input_icons_gamepad
input_trigger_effect_weapon
FirebaseREST_Firestore_collection_compare
getMessageHeight
input_player_using_gamepad
input_vibrate_stop
input_cursor_limit_aabb
__input_class_gamepad
input_motion_data_get
input_gamepad_tester_get
input_accessibility_global_toggle_get
__input_steam_type_set
__input_gamepad_set_description
input_profile_export
input_profile_get
input_value_is_binding
__input_exception_handler
array_to_string
input_vibrate_set_pause
FirebaseREST_Firestore_headerToken
__input_window_changed
__input_trace_loud
__input_gamepad_type_swap_ab
scr_loadtrack
input_player_get_gamepad_type
angle_distance
input_join_params_get
__input_config_hotswap
input_gamepad_map_contains
input_trigger_effect_off
__input_load_blacklist_csv
input_verb_get_group
input_mouse_coord_space_get
input_player_gamepad_type_override_set
__input_trace
__input_clear_all
shortestAngularDistance
input_keyboard_check_released
shortestAngularDirection
input_check_opposing_pressed
__input_virtual_player_set
__input_gamepad_tester_tick
input_profile_import
__input_validate_macros
input_join_is_finished
FirebaseREST_Firestore_path_isDocument
__input_transform_coordinate
__input_finalize_default_profiles
input_profile_create
__input_class_chord_state
drawTextWithOutline
input_vibrate_get_pause
input_cursor_mouse_enabled_set
input_binding_is_valid
input_cursor_dy
__input_class_binding
update_audio_pitch
draw_healthbar_border
input_system_verify
input_verb_set
input_combo_params_reset
input_icon_touch
input_binding_test_collisions
__input_gamepad_set_type
input_gamepad_get_description
scr_add_color
parse_action_parameters
input_cursor_gyro_enabled_get
scr_resolution
scr_list_commands
input_accessibility_verb_toggle_get
__input_get_time
scr_list_actions
are_arguments_valid
calculate_color_distance
input_cursor_y
input_binding_get_verbs
load_responses
input_gamepad_constant_get_name
input_binding_scan_params_set
input_is_virtual
input_player_copy
input_cursor_dx
input_xy
updateLongestMessage
draw_text_kern
input_combo_params_set_top_down
__input_steam_handles_changed
input_cursor_x
__input_class_trigger_effect_feedback
__input_load_sdl2_from_string_internal
__input_load_sdl2_from_file
debug_action_details
input_cursor_inverted_get
__input_finalize_verb_groups
input_color_set
input_binding_gamepad_button
input_icon_empty
check_gamepad_input
command_requires_arguments
__input_config_cursor
input_check_released
input_vibrate_adsr
input_binding_set_safe
contains_profanity
nextSpawnTime
__input_key_name_set



########## update_code.py.txt ##########
from flask import Blueprint, jsonify, request
import os
import requests

update_code_route = Blueprint('update_code_route', __name__)

@update_code_route.route('/update_code', methods=['POST'])
def update_code():
    data = request.get_json()
    file_path = data.get('file_path')
    new_content = data.get('new_content')
    commit_message = data.get('commit_message')

    if not file_path or not new_content or not commit_message:
        return jsonify({"error": "Missing required fields"}), 400

    GITHUB_API_URL = os.getenv('GITHUB_API_URL')
    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

    headers = {
        'Authorization': f'token {GITHUB_TOKEN}',
        'Accept': 'application/vnd.github.v3+json',
    }
    try:
        get_file_response = requests.get(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers)
        get_file_response.raise_for_status()
        file_sha = get_file_response.json().get('sha')

        update_data = {
            'message': commit_message,
            'content': new_content,
            'sha': file_sha,
        }
        update_response = requests.put(f'{GITHUB_API_URL}/contents/{file_path}', headers=headers, json=update_data)
        update_response.raise_for_status()
        return jsonify(update_response.json())
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## generate_prompt.py.txt ##########
from flask import Blueprint, jsonify

generate_prompt_route = Blueprint('generate_prompt_route', __name__)

def read_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, 'w') as file:
        file.write(content)

@generate_prompt_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    data = request.get_json()
    prompt_type = data.get('type')
    item_name = data.get('name')
    save_name = data.get('save_name')
    additional_instructions = data.get('additional_instructions', '')

    if not save_name:
        return jsonify({"error": "Invalid input, 'save_name' field is required"}), 400

    intro = read_file('intro.txt')
    format_description = read_file('format_description.txt')

    if not intro or not format_description:
        return jsonify({"error": "Intro or format description files not found"}), 400

    try:
        if prompt_type == 'bug':
            with open('bug_list.json', 'r') as f:
                bug_list = json.load(f)
            item = next((bug for bug in bug_list if bug['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Bug not found"}), 400

        elif prompt_type == 'feature':
            with open('planned_features.json', 'r') as f:
                feature_list = json.load(f)
            item = next((feature for feature in feature_list if feature['name'] == item_name), None)
            if not item:
                return jsonify({"error": "Feature not found"}), 400

        else:
            return jsonify({"error": "Invalid prompt type"}), 400
    except json.JSONDecodeError as e:
        return jsonify({"error": f"JSON Decode Error: {e}"}), 500

    prompt = f"{intro}\n\n{item['description']}\n\n{format_description}\n\nAdditional Instructions: {additional_instructions}\n\n"

    for script in item['related_scripts']:
        script_path = f"YEAN CAT/scripts/{script}/{script}.gml"
        script_content = read_file(script_path)
        if script_content:
            prompt += f"Script {script}:\n{script_content}\n\n"

    for obj in item['related_objects']:
        obj_path = f"YEAN CAT/objects/{obj}/"
        if os.path.isdir(obj_path):
            for filename in os.listdir(obj_path):
                if filename.endswith('.gml'):
                    file_content = read_file(os.path.join(obj_path, filename))
                    if file_content:
                        prompt += f"Object {obj} ({filename}):\n{file_content}\n\n"

    log_contents = []
    for log in item['logs']:
        log_content = read_file(f'Logs/{log}')
        if log_content:
            log_contents.append(log_content)
    prompt += "Logs:\n" + "\n".join(log_contents) + "\n\n"

    prompt_file_path = f'prompts/{save_name}.txt'
    write_file(prompt_file_path, prompt)

    return jsonify({"message": f"Prompt saved as '{prompt_file_path}'"})



########## assistant.py.txt ##########
from flask import Blueprint, request, jsonify
import threading
import requests
import os

assistant_route = Blueprint('assistant_route', __name__)

thread_lock = threading.Lock()
user_threads = {}

@assistant_route.route('/assistant', methods=['POST'])
def assistant():
    data = request.get_json()
    message = data.get('message')
    thread_id = data.get('thread_id', 'default')
    if not message:
        return jsonify({"error": "Invalid input, 'message' field is required"}), 400

    with thread_lock:
        if thread_id not in user_threads:
            user_threads[thread_id] = []

    try:
        response = requests.post(
            'https://api.openai.com/v1/assistants',
            headers={'Authorization': f'Bearer ' + os.getenv("ASSISTANT_API_KEY")},
            json={
                'message': message,
                'thread_id': thread_id,
                'context': user_threads[thread_id]
            }
        )
        response.raise_for_status()
        assistant_response = response.json()

        with thread_lock:
            user_threads[thread_id].append({"role": "assistant", "content": assistant_response['message']})

        return jsonify(assistant_response)
    except requests.exceptions.RequestException as e:
        return jsonify({"error": str(e)}), 500



########## query.py.txt ##########
from flask import Blueprint, jsonify
from utils.pinecone_operations import init_pinecone_index, upsert_vectors_to_pinecone

query_openai_route = Blueprint('query_openai_route', __name__)

index_name = "yean-cat-git-gpt-index"  # Use the correct index name
pinecone_instance = init_pinecone_index(index_name)
index = pinecone_instance.Index(index_name)

@query_openai_route.route('/query', methods=['POST'])
def query_openai():
    # Your endpoint logic here
    return jsonify({"message": "Pinecone index queried successfully"})

@query_openai_route.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    # Your endpoint logic here
    return jsonify({"message": "GPT prompt generated successfully"})

@query_openai_route.route('/update_code', methods=['POST'])
def update_code():
    # Your endpoint logic here
    return jsonify({"message": "Code updated successfully"})

@query_openai_route.route('/assistant', methods=['POST'])
def assistant():
    # Your endpoint logic here
    return jsonify({"message": "Assistant query successful"})



########## README.md.txt ##########
# Yean Cat
 Gamemaker Studio 2 Project

## Overview
Yean Cat is a 2D side-scrolling open-world game developed using GameMaker Studio 2. The game features multiple planets, player progression, and rhythm-based elements.

## Features
- Multiplayer functionality
- Dynamic quests and content generation
- Gamepad support for Xbox, PS5, and Switch controllers

## Setup
1. Clone the repository.
2. Open the project in GameMaker Studio 2.
3. Follow the instructions in `docs/setup.md` for additional configuration.

## Usage
- Use the command system to create and manage game content.
- Refer to the in-game help menu for command syntax and examples.

## Contributing
Currently, this project is maintained by a single developer. Contributions are not open at this time.



########## server.py.txt ##########
from flask import Flask
from dotenv import load_dotenv
import os
import threading
from routes.query import query_openai_route
from routes.assistant import assistant_route
from routes.generate_prompt import generate_prompt_route
from routes.update_code import update_code_route

# Initialize the thread lock
thread_lock = threading.Lock()

# Load environment variables from a .env file
load_dotenv()

# Create a Flask application instance
app = Flask(__name__)

# Define a simple route for the home page
@app.route('/')
def home():
    return "Hello, this is the home page of Yean-Cat!"

# Register blueprints for different routes
app.register_blueprint(query_openai_route, url_prefix='/api')
app.register_blueprint(generate_prompt_route, url_prefix='/api')
app.register_blueprint(update_code_route, url_prefix='/api')
app.register_blueprint(assistant_route, url_prefix='/api')

# Main entry point for the application
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() == 'true'
    app.run(debug=debug_mode, host='0.0.0.0', port=port)



########## gitignore.txt ##########
# GameMaker Studio 2 specific files
*.yyc
*.yyp
*.yys
*.yyw
*.yyz
*.yydebug
*.win
*.linux
*.osx
*.ios
*.android

# Temporary files
*.tmp
*.temp

# System files
.DS_Store
Thumbs.db

# Environment variables
.env
code_text/env.txt





