Feature Name: Chat_Bubbles_with_Choices
Description: Implement customizable chat bubbles with 2-4 selectable choices, allowing for branching dialogues and multiple action triggers per choice.

== Related Objects ==

Object: obj_chat_bubble

File: Step_0.gml
Code:
// obj_chat_bubble: Step Event
if (owner != noone) {
    x = owner.x;
    y = owner.y - 60;
}

if wrapped = 0 {
    draw_set_font(text_font);
    draw_set_halign(fa_middle);
    draw_set_valign(fa_top);
    var longestWordWidth = get_longest_word_width(_text, text_font, text_scale);
    text_scale = min(clamp(1-string_length(_text)/500,.5,1),clamp(1.5-longestWordWidth/1000,.5,1))
    max_width = clamp(max(500+string_length(_text)*1.5,longestWordWidth/2+250),min_width,1500)
    _text = wrap_text(_text, max_width - 2 * padding);
    line_count = string_count("\n", _text) + 1;
    scale_x = clamp(string_width(_text) + 6 * padding, min_width, max_width);
    real_scale_y = clamp(((line_count-1) * (string_height("M")+30*text_scale)) * 1.5 * text_scale / 2+120, min_height-120, max_height-120);
    wrapped = 1
}

scale_y = real_scale_y + 120

if sprite_get_xoffset(sprite_index) = 250 {
    facing = 0
} else if sprite_get_xoffset(sprite_index) > 250 {
    facing = -1
} else {
    facing = 1
}

if (choice_count > 0) {
    var choice_start_y = y + real_scale_y + 20;
    
    for (var i = 0; i < choice_count; i++) {
        var choice_text = choices[i][0];
        draw_set_font(text_font);
        var choice_text_width = string_width(choice_text) * text_scale;
        var choice_text_height = string_height(choice_text) * text_scale;
        var choice_scale_x = max(choice_text_width + padding * 4, min_width);
        var choice_scale_y = max(choice_text_height + padding * 2, min_height - 120);
        
        var choice_x = x - choice_scale_x / 2;
        var choice_y = choice_start_y + (i * (choice_scale_y + 10));
        
        if (point_in_rectangle(mouse_x, mouse_y, choice_x, choice_y, choice_x + choice_scale_x, choice_y + choice_scale_y)) {
            if (mouse_check_button_pressed(mb_left)) {
                selected_choice = i;
                if (choices[i][1] != undefined && choices[i][1] != "") {
                    scr_execute_action(choices[i][1]);
                }
                instance_destroy();
                return;
            }
        }
    }
}

lifetime++;
if (lifetime >= duration && choice_count == 0) {
    instance_destroy();
}



File: Draw_0.gml
Code:
// obj_chat_bubble Draw Event

// Draw main chat bubble
var tail_sprite_index = 0;
var middle_sprite_index = 1;
var top_sprite_index = 2;

var bottom_y = y;
var top_y = y - real_scale_y;
var middle_height = clamp(scale_y - 240, 0, max_height - 120);
var middle_y = y - sprite_get_yoffset(sprite_index) - (120 - sprite_get_yoffset(sprite_index)) * middle_height / 120;

var top_middle_x = x - (sprite_get_xoffset(sprite_index) - 250) * scale_x / 500;
var top_middle_y = y - sprite_get_yoffset(sprite_index) - middle_height - 60;

draw_sprite_ext(sprite_index, tail_sprite_index, x, bottom_y, scale_x / 500, 1, 0, c_white, 1);
draw_sprite_ext(sprite_index, middle_sprite_index, x, middle_y, scale_x / 500, middle_height / 120, 0, c_white, 1);
draw_sprite_ext(sprite_index, top_sprite_index, x, top_y, scale_x / 500, 1, 0, c_white, 1);

draw_set_font(text_font);
draw_set_halign(fa_middle);
draw_set_valign(fa_top);
drawTextWithOutline(top_middle_x, top_middle_y + padding, _text, text_scale, outline_size, text_color_outline, text_color);

// Draw choices
if (choice_count > 0) {
    var choice_start_y = bottom_y + 20; // Start drawing choices below the main bubble
    
    for (var i = 0; i < choice_count; i++) {
        var choice_text = choices[i][0];
        
        // Calculate choice bubble dimensions
        draw_set_font(text_font);
        var choice_text_width = string_width(choice_text) * text_scale;
        var choice_text_height = string_height(choice_text) * text_scale;
        var choice_scale_x = max(choice_text_width + padding * 4, min_width);
        var choice_scale_y = max(choice_text_height + padding * 2, min_height - 120);
        
        // Draw choice bubble
        var choice_x = x;
        var choice_y = choice_start_y + (i * (choice_scale_y + 10)); // 10 pixel vertical spacing between choices
        
        // Bottom (tail) - we don't need a tail for choices
        draw_sprite_ext(spr_chatchoice1, 0, choice_x, choice_y + choice_scale_y, choice_scale_x / 500, 1, 0, c_white, 1);
        
        // Middle
        var choice_middle_height = choice_scale_y - 120;
        if (choice_middle_height > 0) {
            draw_sprite_ext(spr_chatchoice1, 1, choice_x, choice_y + 60, choice_scale_x / 500, choice_middle_height / 120, 0, c_white, 1);
        }
        
        // Top
        draw_sprite_ext(spr_chatchoice1, 2, choice_x, choice_y, choice_scale_x / 500, 1, 0, c_white, 1);
        
        // Draw choice text
        var choice_text_x = choice_x;
        var choice_text_y = choice_y + padding;
        drawTextWithOutline(choice_text_x, choice_text_y, choice_text, text_scale, outline_size, text_color_outline, text_color);
    }
}

File: Create_0.gml
Code:
//CREATE EVENT of obj_chat_bubble

// Add these variables to the existing Create event
choices = [];
choice_count = 0;
selected_choice = -1;

// Initialize default properties
_text = "";
line_count = 1;
owner = noone;
max_width = 500;  // Maximum width of the chat bubble
max_height = 800;  // Maximum height of the chat bubble
min_width = 200;
min_height = 240;
padding = 15;
scale_y = min_height;  // Default size in pixels for a 1-line chat bubble
scale_x = min_width;  // Default size in pixels
real_scale_y= min_height-120
duration = 1000;  // Chat bubble display duration in frames
lifetime = 0;
sprite_index = spr_chatbubble1;
if (owner != noone) {
    x = owner.x;
    y = owner.y - 60;  // Adjust to appear above the owner's head
}
text_font = Font_Default;
text_color = c_dkgrey;
text_color_outline = c_black;
text_scale = 1;
outline_size = 2;
wrapped=0


File: obj_chat_bubble.yy
Code:
{
  "$GMObject":"",
  "%Name":"obj_chat_bubble",
  "eventList":[
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":0,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":3,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":8,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
  ],
  "managed":true,
  "name":"obj_chat_bubble",
  "overriddenProperties":[],
  "parent":{
    "name":"ui",
    "path":"folders/Objects/ui.yy",
  },
  "parentObjectId":null,
  "persistent":false,
  "physicsAngularDamping":0.1,
  "physicsDensity":0.5,
  "physicsFriction":0.2,
  "physicsGroup":1,
  "physicsKinematic":false,
  "physicsLinearDamping":0.1,
  "physicsObject":false,
  "physicsRestitution":0.1,
  "physicsSensor":false,
  "physicsShape":1,
  "physicsShapePoints":[],
  "physicsStartAwake":true,
  "properties":[],
  "resourceType":"GMObject",
  "resourceVersion":"2.0",
  "solid":false,
  "spriteId":{
    "name":"spr_chatbubble1",
    "path":"sprites/spr_chatbubble1/spr_chatbubble1.yy",
  },
  "spriteMaskId":null,
  "visible":true,
}

Object: obj_Client

File: Step_0.gml
Code:
/// Step Event of obj_Client

//create mouse if it doesnt exist and using keyboard and mouse
if !instance_exists(obj_Cursor) and (global.control_type!=1) { 
	instance_create_depth(mouse_x,mouse_y,-1000000,obj_Cursor);
}

// Set current font and heartbeat rate
global.heartbeatBPM = global.current_bpm;
fnt_chat = master.font_array[fnt_chat_id, 1];
global.wrapWidth = 2350; // Adjusted wrap width

//check for gamepad input
check_gamepad_input()

//randomly and probability skewed to bring shake_angle back to 0
if abs(shake_angle)>.1 {
	var invert = choose(-1,1)*(random(8)+92)/100
	shake_angle=round(invert*shake_angle*100)/100
} else {
	if shake_angle!=0 {
	shake_angle=0
	keyboard_lastkey=vk_nokey
	}
}

// Handle reconnection logic
if (!global.isConnected && global.reconnectTimer <= 0) {
    var result = network_connect(global.client_socket, global.serverAddress, global.serverPort);
    if (result >= 0) {
        global.isConnected = true;
        isServerRunning = true;
        show_debug_message("[Client] Successfully reconnected to server.");
        global.reconnectTimer = global.reconnectInterval;
    } else {
        global.reconnectTimer = global.reconnectInterval;
        isServerRunning = false;
        show_debug_message("[Client] Failed to reconnect to server. Will try again...");
    }
} else if (global.isConnected && global.reconnectTimer > 0) {
    global.reconnectTimer--;
}

// Handle incoming network events safely
if (ds_exists(async_load, ds_type_map)) {
    var type = ds_map_find_value(async_load, "type");
    var n_id = ds_map_find_value(async_load, "id");

    if (n_id == global.client_socket) {
        switch (type) {
            case network_type_data:
                var buffer = ds_map_find_value(async_load, "buffer");
                buffer_seek(buffer, buffer_seek_start, 0);
                var identifier = buffer_read(buffer, buffer_u8);

                switch (identifier) {
                    case global.IDENTIFIER_HEARTBEAT:
                        show_debug_message("[Client] Heartbeat received from server.");
                        break;
                    
                    case global.IDENTIFIER_TEST_MESSAGE:
                        var msg = buffer_read(buffer, buffer_string);
                        show_debug_message("[Client] Message from server: " + msg);
                        break;
                }
                buffer_delete(buffer);
                break;

            case network_type_connect:
                show_debug_message("[Client] Connected to server.");
                break;
                
            case network_type_disconnect:
                global.isConnected = false;
                show_debug_message("[Client] Disconnected from server. Attempting to identify cause...");
                break;
        }
    }
} else {
    show_debug_message("ERROR: Invalid ds_map reference in async event.");
}

// Command input and execution logic
if (input_check_pressed("chat") && !isActive) {
    isActive = true;
    global.commandBuffer = "";
    keyboard_string = "";
    show_debug_message("[Client] Chat input activated.");
}

// Toggle chat box with a specific key, e.g., Tab
if (keyboard_check_pressed(vk_tab)) {
    show_chatbox = !show_chatbox;
    global.commandBuffer = "";  // Clear previous commands or texts
    keyboard_string = "";
    show_debug_message("[Client] Toggled chat box visibility: " + string(show_chatbox));
}

// Handle backspace and text input
if (isActive) {
// Handle backspace input
    if (input_check("cancel") && string_length(global.commandBuffer) > 0) {
        if (global.backspaceTimer == 0 || global.backspaceTimer >= global.backspaceDelay) {
            var lastCharPosition = string_length(global.commandBuffer);

            // Check if the last character is a newline
            if (string_char_at(global.commandBuffer, lastCharPosition) == "\n") {
                // Adjust the global.lastSpaceIndex if necessary
                if (global.lastSpaceIndex >= lastCharPosition) {
                    global.lastSpaceIndex = string_last_index_of(string_copy(global.commandBuffer, 1, lastCharPosition - 1), " ");
                }
            }

            // Perform the character deletion
            global.commandBuffer = string_delete(global.commandBuffer, lastCharPosition, 1);
            update_chat_input_visuals();
            show_debug_message("[Client] Updated command buffer after backspace: " + global.commandBuffer);

            // Clear the keyboard buffer to avoid unwanted characters
            keyboard_string = "";

            // Increase deletion speed
            if (global.backspaceTimer == 0) {
                global.backspaceTimer = 1;
            } else {
                global.backspaceTimer = global.backspaceSpeed;
				if global.backspaceSpeed<14 {
					global.backspaceSpeed+=1
				}
            }
        } else {
            global.backspaceTimer += 1;
        }
    } else {
        global.backspaceTimer = 0; // Reset timer when backspace is released
		global.backspaceSpeed=1
    }
	if string_length(global.commandBuffer)<global.character_limit {
    var char = keyboard_string;
	} else {
		var char = "";
		if keyboard_check_pressed(vk_anykey) {
		if last_key_is_valid_character(keyboard_lastkey) {
			//play sound to indicate char limit. 
			var sound = audio_play_sound(uibuttonsound7,0,0,master.uivol*master.mastervol)
			shake_angle=choose(-1,1)*random_range(.95,1.00)
		}
		}
	}
    // Detect pasting via Ctrl+V (Windows) or Command+V (Mac)
    var pasting = false;
    if (os_type == os_windows) {
        if (keyboard_check(vk_control) && keyboard_check_pressed(ord("V"))) {
            pasting = true;
			keyboard_string=""
			char = ""
        }
    } else if (os_type == os_macosx) {
        if (keyboard_check(92) && keyboard_check_pressed(ord("V"))) {
            pasting = true;
			keyboard_string=""
			char = ""
        }
    }

    // Handle pasting
    if (pasting) {
        if (clipboard_has_text()) {
            var clip_string = clipboard_get_text();
            if (string_length(clip_string) > 0 && string_length(clip_string) < 200) {
                global.commandBuffer = appendAndWrap(clip_string, global.commandBuffer, global.wrapWidth);
                update_chat_input_visuals();
                show_debug_message("[Client] Appended clipboard content to command buffer: " + global.commandBuffer);
            } else {
                handleDebugMessage("Clipboard content is too long to paste!", true);
            }
        }
        pasting = false;
    }

    if (char != "") {
        // Prevent typing if command is filled
        if (!((global.textColor == c_lime || global.textColor == c_red) && slash_typed)) {
            draw_set_font(fnt_chat);
            global.commandBuffer = appendAndWrap(char, global.commandBuffer, global.wrapWidth);
        }
        update_chat_input_visuals();
        keyboard_string = ""; // Clear the buffer after reading
        show_debug_message("[Client] Appended character to command buffer: " + global.commandBuffer);
    }

// Check if Enter is pressed to process the command or chat message
if (input_check_pressed("confirm")) {
        if (string_char_at(global.commandBuffer, 1) == "/") {
            var command = string_delete(global.commandBuffer, 1, 1);
            execute_command(string_trim(command));
        } else {
            var chatMessage = "[" + master.playername + "] " + global.commandBuffer;
            global.message_is_bubble = 1;
            handleDebugMessage(chatMessage, true);
            global.message_is_bubble = 0;
        }

        // Add the command/message to the recall list
        if (string_length(global.commandBuffer) > 0) {
            ds_list_add(global.recall_list, global.commandBuffer);
            if (ds_list_size(global.recall_list) > global.recall_max) {
                ds_list_delete(global.recall_list, 0);  // Remove the oldest entry if exceeding the limit
            }
        }
        global.recall_index = -1;
        global.textColor = global.defaultTextColor;
        global.commandBuffer = "";
        isActive = false;
        show_debug_message("[Client] Processed command/chat and cleared buffer.");
}
    // Navigate through the recall list using up and down arrows
    if (keyboard_check_pressed(vk_up)) {
        if (global.recall_index == -1) {
            global.recall_index = ds_list_size(global.recall_list) - 1;
        } else {
            global.recall_index = max(0, global.recall_index - 1);
        }

        if (global.recall_index >= 0 && global.recall_index < ds_list_size(global.recall_list)) {
            global.commandBuffer = ds_list_find_value(global.recall_list, global.recall_index);
            update_chat_input_visuals();
            show_debug_message("[Client] Recalled previous command/chat: " + global.commandBuffer);
        }
    } else if (keyboard_check_pressed(vk_down)) {
        if (global.recall_index != -1) {
            global.recall_index = min(ds_list_size(global.recall_list) - 1, global.recall_index + 1);

            if (global.recall_index < ds_list_size(global.recall_list)) {
                global.commandBuffer = ds_list_find_value(global.recall_list, global.recall_index);
            } else {
                global.commandBuffer = "";
            }
            update_chat_input_visuals();
            show_debug_message("[Client] Recalled next command/chat: " + global.commandBuffer);
        }
    }
}

// Before calling drawChatMessages, ensure messages is a ds_list
if (!ds_exists(global.debugMessages, ds_type_list)) {
    show_debug_message("Error: debugMessages is not a valid ds_list.");
    return;
}

if show_chatbox and ds_exists(global.debugMessages, ds_type_list) {
var totalLines = drawChatMessages(global.debugMessages, 990, 0, global.max_visible_lines, .5, false,global.c_chat2,global.c_chat1);
// Ensure scrollIndex is within valid range
scrollIndex = clamp(scrollIndex, 0, clamp(totalLines - global.max_visible_lines,0,999999));
}

// Only process incoming data and send heartbeats if the server is running
if (isServerRunning && sendHeartbeat && (current_time - global.lastHeartbeatTime >= broadcastInterval)) {
    handleDebugMessage("Heartbeat sent to Server", true);
    global.lastHeartbeatTime = current_time;
}





File: Other_68.gml
Code:
// Async Networking Event Handling for Client

/// Revised Async Networking Event
var type = ds_map_find_value(async_load, "type");
var n_id = ds_map_find_value(async_load, "id");

if (n_id == global.client_socket) {
    switch (type) {
        case network_type_connect:
            show_debug_message("[Client] Connected to server.");
            global.isConnected = true;
            break;
        case network_type_disconnect:
            show_debug_message("[Client] Disconnected from server.");
            global.isConnected = false;
            break;
        case network_type_data:
            if (ds_map_exists(async_load, "buffer")) {
                var buffer = ds_map_find_value(async_load, "buffer");
                if (buffer != undefined) {
                    buffer_seek(buffer, buffer_seek_start, 0);
                    var identifier = buffer_read(buffer, buffer_u8);
                    handleNetworkData(identifier, buffer);
                } else {
                    show_debug_message("ERROR: Buffer not found in data event.");
                }
            } else {
                show_debug_message("ERROR: 'buffer' key does not exist in the async_load map.");
            }
            break;
    }
} else {
    show_debug_message("ERROR: Invalid socket ID reference in async event.");
}


//// Async Networking Event of obj_Client

//var type = ds_map_find_value(async_load, "type");
//var n_id = ds_map_find_value(async_load, "id");

//if (n_id == global.client_socket) {
//    switch (type) {
//        case network_type_data:
//            var buffer = ds_map_find_value(async_load, "buffer");
//            buffer_seek(buffer, buffer_seek_start, 0);
//            var identifier = buffer_read(buffer, buffer_u8);

//            switch (identifier) {
//                case global.IDENTIFIER_HEARTBEAT:
//                    // Handle heartbeat received from the server
//                    show_debug_message("[Client] Heartbeat received from server.");
//                    // Optionally, send back a confirmation or keep alive message
//                    break;
                
//                case global.IDENTIFIER_UNIQUE_ID:
//                    // This would be where the server confirms receipt of your unique ID
//                    // Or any other custom logic for unique ID handling
//                    var confirmationMessage = buffer_read(buffer, buffer_string);
//                    show_debug_message("[Client] Server confirmed Unique ID: " + confirmationMessage);
//                    break;
                
//                // Add more case handlers for different data types as needed
//            }
//            buffer_delete(buffer);
//            break;

//        case network_type_connect:
//            // Immediately upon connection, send the unique ID to the server
//            // This ensures server is aware of who just connected
//            var buffer = buffer_create(256, buffer_grow, 1);
//            buffer_seek(buffer, buffer_seek_start, 0);
//            buffer_write(buffer, buffer_u8, global.IDENTIFIER_UNIQUE_ID);
//            buffer_write(buffer, buffer_string, global.clientUniqueID);
//            network_send_packet(global.client_socket, buffer, buffer_tell(buffer));
//            show_debug_message("[Client] Sent unique ID to server: " + global.clientUniqueID);
//            buffer_delete(buffer);
//            break;
            
//        case network_type_disconnect:
//            // Handle disconnection logic here, if needed
//            global.isConnected = false; // Update the connection status
//            show_debug_message("[Client] Disconnected from server.");
//            break;
//    }
//}


File: Destroy_0.gml
Code:
///Destroy Event for obj_Client
if (global.isConnected) {
    network_destroy(global.client_socket);
}


//// Clean up dynamic resources
//if (ds_exists(clien, ds_type_map)) {
//    ds_map_destroy(myDataStructure);
//}

// Optionally, inform the master object or handle game state changes
// For example, transition to a different room or update the UI
//event_perform_object(obj_Master, ev_Other, ev_user0); // Custom user event for cleanup in obj_Master


File: Draw_0.gml
Code:
///Client Draw Code
draw_set_font(fnt_chat);
if show_chatbox=true {
	var xx = 990;
	var yy = 686; // Starting y position
	var lm_cal=clamp(xx+(clamp(110-global.longestmessage,0,110))+1.65*(global.longestmessage-50)/3,xx+215,(display_get_gui_width()-10)/2+room_width/2)+10
	var x1 = 980
	var y1 = 686-20
	var x2 = max(lm_cal,clamp(xx+(clamp(110-global.longestmessage,0,110))+1.65*(string_width(global.commandBuffer)-1)/3,xx+215,(display_get_gui_width())/2+room_width/2+50))
	var y2 = _yy+100
	//draw transparent background box for chatbox that adjusts to fit the longest message. will be later swapped for a scaled image background
	draw_rectangle_outlined(x1,y1,x2,y2,false,global.borderwidth,global.o_color,global.bg_color,global.bg_alpha);
	draw_set_alpha(1);
	var sca=.7
	global.chat_line_height = 70 * sca + 5;
// Set drawing properties
draw_set_colour(c_ltgray);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_font(fnt_chat); 
// Display server status
var serverStatus = "Server Unable to Connect"; // Default message
if (isServerRunning) {
    serverStatus = "Server Online";
	draw_set_colour(c_lime);
} else {
    serverStatus = "Server Stopped";
	draw_set_colour(c_red);
}

if show_server_status=true {
draw_text_transformed(xx, yy, serverStatus, sca, sca, 0);
yy += 40; // Increment y position for next line
}

if connectedClients>0 {
	draw_set_colour(c_aqua);
} else {
	draw_set_colour(c_ltgrey);
}
if show_server_status=true {
	//we can keep drawing this section this way unless somehow your next response can condense it as well. but its  kind of fine as is, no issues here.
draw_text_transformed(xx+3, yy+3-10, "Connected Clients: "+string(connectedClients), sca, sca, 0);
draw_text_transformed(xx-3, yy+3-10, "Connected Clients: "+string(connectedClients), sca, sca, 0);
draw_text_transformed(xx+3, yy-3-10, "Connected Clients: "+string(connectedClients), sca, sca, 0);
draw_text_transformed(xx-3, yy-3-10, "Connected Clients: "+string(connectedClients), sca, sca, 0);
draw_set_color(global.c_chat1);
draw_text_transformed(xx, yy-10, "Connected Clients: "+string(connectedClients), sca, sca, 0);
yy += 50; // Increment y position for next 
} else {
	draw_set_color(global.c_chat1);
	draw_text_transformed(xx+3, yy+3-10, "Chat Box", sca, sca, 0);
	draw_text_transformed(xx-3, yy+3-10, "Chat Box", sca, sca, 0);
	draw_text_transformed(xx+3, yy-3-10, "Chat Box", sca, sca, 0);
	draw_text_transformed(xx-3, yy-3-10, "Chat Box", sca, sca, 0);
	draw_set_color(global.c_chat2);
	draw_text_transformed(xx, yy-10, "Chat Box", sca, sca, 0);
yy += 60; // Increment y position for next line
}

sca=.5

if show_chatbox and ds_exists(global.debugMessages, ds_type_list) {
    var startY = yy;
    var maxLinesToShow = global.max_visible_lines;
	// Before calling drawChatMessages, ensure messages is a ds_list
if (!ds_exists(global.debugMessages, ds_type_list)) {
    show_debug_message("Error: debugMessages is not a valid ds_list.");
    return;
}

    var totalLines = drawChatMessages(global.debugMessages, 990, startY, maxLinesToShow, sca, false,global.c_chat2,global.c_chat1);

    // Calculate the max index for scrolling based on the total number of lines
    var maxScrollIndex = max(0, clamp(totalLines - maxLinesToShow,0,9999999));

    // Scroll messages with keyboard or mouse wheel
    if (input_check("up") || mouse_wheel_up()) {
		if !(input_check("up") and isActive = true) { //disable scrolling from "W" when typing
        scrollIndex = max(0, scrollIndex - 1);
        show_debug_message("[Client] Scrolled up: Current scroll index is " + string(scrollIndex));
		}
    }
    if (input_check("down") || mouse_wheel_down()) {
		if !(input_check("down") and isActive = true) {//disable scrolling from "S" when typing
        scrollIndex = min(maxScrollIndex, scrollIndex + 1);
        show_debug_message("[Client] Scrolled down: Current scroll index is " + string(scrollIndex));
		}
    }

    // Ensuring scrollIndex is always within the valid range
    scrollIndex = clamp(scrollIndex, 0, maxScrollIndex);

    // Redraw messages considering the scroll index
	// Before calling drawChatMessages, ensure messages is a ds_list
if (!ds_exists(global.debugMessages, ds_type_list)) {
    show_debug_message("Error: debugMessages is not a valid ds_list.");
    return;
}

    drawChatMessages(global.debugMessages, 990, yy , maxLinesToShow, sca, true,global.c_chat2,global.c_chat1);
}

yy=yy+clamp(totalLines-scrollIndex,0,global.max_visible_lines)*(global.chat_line_height*1.00)+5
sca=.6
_yy=yy-15
 
if (isActive) {
// Determine the number of line breaks in the command buffer
var lineCount = array_length(string_split(global.commandBuffer, "\n"));

// Calculate the new height based on the number of lines
var lines = string_split(global.commandBuffer, "\n");
var boxHeight = global.chat_line_height*1.05 * array_length(lines) + 2; // Calculate box height based on number of lines

//chat input box drawing code 
draw_set_color(c_black); // Set initial color to black (border)
 
    if (string_char_at(global.commandBuffer, 1) = "/") {
        draw_set_color(c_white);  // border becomes white if command is being typed
    }
// Adjust the bottom y-coordinate of the rectangle to expand with each new line
draw_rectangle(xx + 5, yy - 11, clamp(xx - 90 + 1.85 * (string_width(global.commandBuffer) - 1) / 3, xx - 90, (display_get_gui_width() - 10) / 2 + room_width / 2) + 150 + 10, yy + boxHeight + 10, false);

    draw_set_color(c_white);  // Set initial bg color to white when no '/' detected
    if (string_char_at(global.commandBuffer, 1) = "/") {
        draw_set_color(c_black);  // Default bg color if command is being typed
		slash_typed=true
    } else {
		slash_typed=false
	}
draw_rectangle(xx + 10, yy - 6, clamp(xx - 90 + 1.85 * (string_width(global.commandBuffer) - 1) / 3, xx - 90, (display_get_gui_width() - 10) / 2 + room_width / 2) + 150, yy + boxHeight, false);
//draw command buffer
draw_set_color(global.c_chat2);
	//we stay drawing these like this because theres no need for line handling here.

	draw_set_color(merge_color(global.textColor,c_red,clamp(abs(shake_angle),0,1)));
    draw_text_transformed(xx+20+shake_angle*7, yy-shake_angle*7, global.commandBuffer + "_", sca, sca, shake_angle*.25);  // Shoblinking cursor
} else {
	draw_set_color(merge_color(global.c_chat1,c_red,clamp(abs(shake_angle),0,1)));
    draw_text_transformed(xx+20+shake_angle*7, yy-shake_angle*7, global.commandBuffer + "_", sca, sca, shake_angle*.25);  // Show blinking cursor
}
} else {
	exit
}


// instance_exists(obj_levelup) {
//if input_value() != undefined {
//draw_set_color(c_red)
//var dbug = ""
//draw_text_transformed(room_width/2,room_height/2,string(global.choiceselect),3,3,0)
//draw_text_transformed(room_width/2,room_height/2,dbug,3,3,0)
//}

////debug draw last key id
//draw_set_color(c_black);
//draw_text(room_width/2+2,room_height/2+2,keyboard_lastkey)
//draw_text(room_width/2-2,room_height/2+2,keyboard_lastkey)
//draw_text(room_width/2+2,room_height/2-2,keyboard_lastkey)
//draw_text(room_width/2-2,room_height/2-2,keyboard_lastkey)
//draw_set_color(c_white);
//draw_text(room_width/2,room_height/2,keyboard_lastkey)

File: Alarm_0.gml
Code:
// Alarm[0] Event
var t_buffer = buffer_create(256, buffer_grow, 1);
buffer_seek(t_buffer, buffer_seek_start, 0);
buffer_write(t_buffer, buffer_u8, global.IDENTIFIER_UNIQUE_ID);
buffer_write(t_buffer, buffer_string, global.clientUniqueID);
network_send_packet(global.client_socket, t_buffer, buffer_tell(t_buffer));
buffer_delete(t_buffer);
global.uniqueIDSent = true; // Ensure we don't resend the unique ID
show_debug_message("[Client] Unique ID sent after delay: " + global.clientUniqueID);


File: obj_Client.yy
Code:
{
  "$GMObject":"",
  "%Name":"obj_Client",
  "eventList":[
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":0,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":3,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":68,"eventType":7,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":1,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":2,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":0,"eventType":8,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
    {"$GMEvent":"v1","%Name":"","collisionObjectId":null,"eventNum":5,"eventType":7,"isDnD":false,"name":"","resourceType":"GMEvent","resourceVersion":"2.0",},
  ],
  "managed":true,
  "name":"obj_Client",
  "overriddenProperties":[],
  "parent":{
    "name":"Objects",
    "path":"folders/Objects.yy",
  },
  "parentObjectId":null,
  "persistent":true,
  "physicsAngularDamping":0.1,
  "physicsDensity":0.5,
  "physicsFriction":0.2,
  "physicsGroup":1,
  "physicsKinematic":false,
  "physicsLinearDamping":0.1,
  "physicsObject":false,
  "physicsRestitution":0.1,
  "physicsSensor":false,
  "physicsShape":1,
  "physicsShapePoints":[],
  "physicsStartAwake":true,
  "properties":[],
  "resourceType":"GMObject",
  "resourceVersion":"2.0",
  "solid":false,
  "spriteId":null,
  "spriteMaskId":null,
  "visible":true,
}

File: Other_5.gml
Code:
/// @description Insert description here
//room end of obj_client
show_chatbox=false

File: Create_0.gml
Code:
// obj_Client setup Create Event
global.sessionLogFileName = "SessionLog_" + string_replace_all(string(date_current_datetime()), ":", "-") + ".txt";
global.masterLogFileName = "MasterLog.txt";
global.logDebugMessagesToFile = true; // By default, log debug messages to the file
global.serverAddress = "127.0.0.1"; // Example server address
// Initialize the data structure globally if not already initialized
global.chatLogs=-1
global.bubble_send_to_log=1
global.message_is_bubble=0
if (!ds_exists(global.chatLogs, ds_type_list)) {
    global.chatLogs = ds_list_create();
}
time=0
// Global Variable Initialization (usually in some global script or create event)
global.typingSpeedCalcDuration = 60; // Default to 60 seconds
global.lastWPMUpdateTime = 0; // Timestamp of the last WPM update
global.WPMUpdateInterval = 5000; // Minimum time between updates in milliseconds (e.g., 5000ms = 5 seconds)
lastUpdateTime = -1;
updateInterval = 60; // Run every 60 seconds
//input
input_cursor_coord_space_set(INPUT_COORD_SPACE.ROOM, 0);
//input_mouse_capture_set(true, 1);
window_set_cursor(cr_none)
instance_create_depth(room_width/2,room_height/2,-1000000,obj_Cursor);
// Global time offset initialized
global.timeOffset = 0;
global.inputDisplayEnabled = false;  // Initialize the variable at an appropriate place in your game startup code

// Adding command details
// Global initialization script or create event
global.commandDetails = ds_map_create();
add_command("goto_planet(", 1, [["string", "real"]], true);  // Requires '(' visually
add_command("jump_planet(", 1, [["string", "real"]], true);  // Requires '(' visually
add_command("toggle_server", 3, [[]], false);  // Does not require '(' visually
add_command("toggle_debug", 1, [[]], false);  // Does not require '(' visually
add_command("list_clients", 1, [[]], false);  // Does not require '(' visually
add_command("enable_heartbeat", 2, [[]], false);  // Does not require '(' visually
add_command("disable_heartbeat", 2, [[]], false);  // Does not require '(' visually
add_command("toggle_log_debug", 2, [[]], false);  // Does not require '(' visually
add_command("set_my_permission(", 0, [["string", "real"]], true);
add_command("save_game", 0, [[]], false);  // Does not require "(" visually
add_command("game_end(", 0, [["string", "real"]], true); 
add_command("list_commands", 0, [[]], false); // No arguments, accessible at all permission levels
add_command("show_lines(", 0, [["real"]], true);
add_command("set_variable(", 2, [["string"],["string","real"]],true)
add_command("level_up(", 1, [["real"]], true);  // Command requires '(' visually and a real number argument
add_command("show_wpm", 0, [[]], false);  // Does not require '(' visually, level 0 permission
add_command("chat_bubble(", 1, [["string"],["string"]],true); // Chat bubble command
add_command("save_macros", 1, [[]], false);  // Add the command to save macros
add_command("list_variables", 2, [[]], false);
add_command("add_action(", 2, [["string"],["string"],["array"]],true);
add_command("save_actions", 2, [], false);
add_command("list_actions", 2, [], false);
add_command("execute_action(", 2, [["string"]], true);
add_command("show_variable(", 2, [["string"]], true);
add_command("return_controller", 1, [[]], false);
add_command("toggle_input_display", 1, [[]], false);
add_command("show_gamepad_mapping", 1, [[]], false);
add_command("chat_bubble_choices(", 1, [["string"], ["string"], ["string", "string"]], true);
add_command("add_chat_bubble_action(", 2, [["string"], ["string"], ["string"], ["array"]], true);
// Initialize global action details
global.actionDetails = ds_map_create();



//add_command("spawn_boss(", 2, [["string"]], true);

//0name //1health //2resistance0-1invincible /3/rate //4attackset //5damage //6moveset //7image //8appearance [0=character,1=boss] //9appearanceid
//add_boss("Drake",6666666,.666,1,1,1,4,spr_boss1,1,0]

// You can add new commands or modify existing ones easily with the `add_command` function.
global.variableDetails = ds_map_create();
add_variable("Level", "level", 1, master, "real", 1, 100000, [], [], "Player");
add_variable("BPM", "target_bpm", 115, global, "real", 1, 100000, [], [], "Gameplay");
add_variable("Time", "ti", 0, master, "real", 0, 99999999, [], [], "Gameplay");
add_variable("WPM Window", "typingSpeedCalcDuration", 60, global, "real", 1, 600, [], [], "Social");
add_variable("CharacterLimit", "character_limit", 1, global, "real", 0, 1000, [], [], "Social");
add_variable("Macro1", "macro1", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro2", "macro2", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro3", "macro3", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro4", "macro4", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro5", "macro5", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro6", "macro6", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro7", "macro7", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro8", "macro8", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro9", "macro9", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("Macro10", "macro10", 1, global, "real", -99999999, 99999999, [], [], "Global");
add_variable("ControllerType", "control_type", 1, global, "real", -99999999, 99999999, [], [], "Global");
global.debugCommand = "";
//global.character_limit
// Ensure commandBuffer is initialized
global.commandBuffer = "";
slash_typed=false //whether or not a command is being typed
// Initialize a global variable for text color
c_pink = make_color_hsv(0,58,255);
global.defaultTextColor = c_black;
global.textColor = global.defaultTextColor;
// Global Variable Initialization (usually in some global script or create event)
global.typingSpeedCalcDuration = 60; // Default to 60 seconds
 // This will store the input from the user
isActive = true;  // To check if command input is active
sendHeartbeat = false; // Control sending of heartbeat messages
_yy=0
pasting=0;
global.longestmessage=200;
global.c_chat2=c_black
global.c_chat1=c_white
fnt_chat=Font4
global.borderwidth=8 //bg width
global.bg_alpha=.4 //bg alpha
global.bg_color=c_black //background color
global.o_color=c_white //outline color
global.wrapWidth = 2350; // Adjust this value based on your chat box
global.character_limit=300;//character limit for chat
global.lastSpaceIndex = -1;

//Other Variables
global.showDebugMessages = true; // Enable debug messages by default
global.maximumMessages=2000;
maxDisplayMessages = 5; // Number of debug messages to display at once
// Initialize max visible lines for the chat box
global.max_visible_lines = maxDisplayMessages;  // You can adjust this number based on your needs

global.debugMessages = ds_list_create();
fnt_chat_id=0
// Global settings for text wrapping
global.chat_threshold = 2350;  // Threshold to start considering wrapping
global.chat_text_limit = 2350; // Maximum pixel width of text before wrapping
global.chat_line_height = 50; // Height of each line of text in pixels
global.min_width = 110;  // Minimum width of the chat box
global.max_width = 1000;  // Maximum width of the chat box, adjust according to your UI design
// Adjust these values to tweak where the text wraps
global.chat_threshold = global.chat_threshold * 1.66;  // Increase the threshold
global.chat_text_limit = global.chat_text_limit * 1.66;  // Increase the width limit

//Scrolling Variables
scrollIndex = 0; // Initialize scroll position
baseScrollSensitivity = 0.1; // Base sensitivity, how much the index changes initially per mouse wheel movement
maxScrollSensitivity = 1.0; // Maximum sensitivity after continuous scrolling
sensitivityIncrement = 0.05; // How much the sensitivity increases with continuous scrolling
sensitivityDecrement = 0.01; // How much the sensitivity decreases when not scrolling
global.scrollSensitivity = baseScrollSensitivity; // Current sensitivity, starts at base sensitivity
global.isScrolling = false; // Tracks if the user is currently scrolling

// Server Configuration
show_server_status=false
global.serverPort = "5555";
global.maxClients = 4;
global.heartbeatBPM = 115; // Beats per minute for the heartbeat
global.lastHeartbeatTime = current_time; // Store the current time
broadcastInterval = 60000 / global.heartbeatBPM; // Time between heartbeats in milliseconds

global.clientUniqueID = ""; // Initialize to an empty string
global.reconnectTimer = 0; // Time to attempt a reconnect
global.reconnectInterval = 2000; // Interval between reconnect attempts
global.isConnected = false; // Connection status
global.IDENTIFIER_UNIQUE_ID = 2; // Ensure this matches server expectation
global.uniqueIDSent = false; // Prevent re-sending

// Initialize server state and structures
isServerRunning = false;
connectedClients = 0;

// Generate or load the unique ID
if (!file_exists(working_directory + "client_id.txt")) {
    // For a new ID
    global.clientUniqueID = string(irandom_range(100000, 999999));
    var file = file_text_open_write(working_directory + "client_id.txt");
    file_text_write_string(file, global.clientUniqueID);
    file_text_close(file);
} else {
    // For an existing ID
    var file = file_text_open_read(working_directory + "client_id.txt");
    global.clientUniqueID = file_text_read_string(file);
    file_text_close(file);
}

// Client Initialization and Connection
global.client_socket = network_create_socket(network_socket_tcp);
var status = network_connect(global.client_socket, global.serverAddress, global.serverPort);
if (status >= 0) {
    // Successful connection
    show_debug_message("[Client] Successfully connected and ID sent.");
	isServerRunning = true;
    var buffer = buffer_create(256, buffer_grow, 1);
    buffer_seek(buffer, buffer_seek_start, 0);
    buffer_write(buffer, buffer_u8, global.IDENTIFIER_UNIQUE_ID);
    buffer_write(buffer, buffer_string, global.clientUniqueID);
    network_send_packet(global.client_socket, buffer, buffer_tell(buffer));
    buffer_delete(buffer);
} else {
    // Handle connection failure
    show_debug_message("[Client] Connection failed.");
}

show_chatbox=false
depth-=10; //ensure at top or front of view

global.backspaceTimer = 0;
global.backspaceDelay = 15; // Initial delay before rapid deletion
global.backspaceSpeed = 1;  // Delay between rapid deletions

global.recall_list = ds_list_create();  // List to store past messages and commands
global.recall_max = 20;  // Maximum number of entries to remember
global.recall_index = -1;  // Index for navigating through the recall list

shake_angle=0 //angle to shake text when character limit reached.

load_actions()


== Related Scripts ==

Script: get_longest_word_width
File: get_longest_word_width.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"get_longest_word_width",
  "isCompatibility":false,
  "isDnD":false,
  "name":"get_longest_word_width",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: get_longest_word_width
File: get_longest_word_width.gml
Code:
/// @function get_longest_word_width(text, font, scale)
/// @description Returns the width of the longest word in a string
/// @param {string} text - The input text
/// @param {font} font - The font to use for width calculation
/// @param {real} scale - The scaling factor for text
/// @return {real} - The width of the longest word
function get_longest_word_width(text, font, scale) {
    draw_set_font(font);
    var words = string_split(text, " ");
    var longestWordWidth = 0;

    for (var i = 0; i < array_length(words); i++) {
        var wordWidth = string_width(words[i]) * scale;
        if (wordWidth > longestWordWidth) {
            longestWordWidth = wordWidth;
        }
    }

    return longestWordWidth;
}

Script: drawTextWithOutline
File: drawTextWithOutline.gml
Code:
// Helper function to draw text with an outline
function drawTextWithOutline(x, y, text, sca, offset, col1, col2) {
    draw_set_color(col1);
    draw_text_transformed(x + offset, y + offset, text, sca, sca, 0);
    draw_text_transformed(x - offset, y + offset, text, sca, sca, 0);
    draw_text_transformed(x + offset, y - offset, text, sca, sca, 0);
    draw_text_transformed(x - offset, y - offset, text, sca, sca, 0);

    draw_set_color(col2);
    draw_text_transformed(x, y, text, sca, sca, 0);
}

Script: drawTextWithOutline
File: drawTextWithOutline.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"drawTextWithOutline",
  "isCompatibility":false,
  "isDnD":false,
  "name":"drawTextWithOutline",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: scr_chat_bubble
File: scr_chat_bubble.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"scr_chat_bubble",
  "isCompatibility":false,
  "isDnD":false,
  "name":"scr_chat_bubble",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: scr_chat_bubble
File: scr_chat_bubble.gml
Code:
/// @function scr_chat_bubble(Text, owner, [choices])
/// @param {string} _text - The text to show in the chat bubble
/// @param {string} _ownerName - The owner object name it will follow
/// @param {array} [_choices] - Optional array of choices, each choice is an array [text, actionName]
function scr_chat_bubble(argument0, argument1, argument2 = []) {
    var _text = string(argument0);
    var _ownerName = string(argument1);
    var _choices = argument2;
    var _owner = asset_get_index(_ownerName);

    if (object_exists(_owner)) {
        var ownerInstance = instance_find(_owner, 0);

        with (obj_chat_bubble) {
            if (owner == ownerInstance) {
                instance_destroy();
            }
        }

        var bubble = instance_create_layer(ownerInstance.x, ownerInstance.y - 60, "uii", obj_chat_bubble);
        bubble._text = _text;
        bubble.owner = ownerInstance;

        bubble.choice_count = array_length(_choices);
        bubble.choices = _choices;

        handleDebugMessage("Chat Bubble Created. Following '" + _ownerName + "' with text: '" + _text + "' and " + string(bubble.choice_count) + " choices", true);
    } else {
        handleDebugMessage("Error: Owner object '" + _ownerName + "' not found", true);
    }
}

Script: scr_add_action
File: scr_add_action.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"scr_add_action",
  "isCompatibility":false,
  "isDnD":false,
  "name":"scr_add_action",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: scr_add_action
File: scr_add_action.gml
Code:
function scr_add_action(argument0, argument1, argument2) {
    var name = string(argument0);
    var commandName = string(argument1);
    var parameters = argument2;
    
    handleDebugMessage("Adding action: " + name + ", Command: " + commandName + ", Parameters: " + string(parameters), true);

    if (ds_map_exists(global.actionDetails, name)) {
        handleDebugMessage("Action '" + name + "' already exists.", true);
        return;
    }
    
    var commandDetailName = commandName + "(";
    handleDebugMessage("Checking for command: " + commandDetailName, true);
    if (!ds_map_exists(global.commandDetails, commandDetailName)) {
        handleDebugMessage("Command '" + commandName + "' does not exist.", true);
        return;
    }
    
    if (!is_array(parameters)) {
        parameters = [parameters];
    } else if (array_length(parameters) == 1 && is_string(parameters[0])) {
        var paramString = string_replace_all(parameters[0], "[", "");
        paramString = string_replace_all(paramString, "]", "");
        parameters = string_split(paramString, ",");
    }
    
    // Special handling for chat_bubble command
    if (commandName == "chat_bubble" && array_length(parameters) >= 3) {
        var choices = [];
        for (var i = 2; i < array_length(parameters); i += 2) {
            array_push(choices, [parameters[i], parameters[i+1]]);
        }
        parameters = [parameters[0], parameters[1], choices];
    }
    
    handleDebugMessage("Parameters after processing: " + string(parameters), true);
    
    var actionEntry = ds_map_create();
    ds_map_add(actionEntry, "command", commandName);
    ds_map_add(actionEntry, "parameters", parameters);
    
    ds_map_add(global.actionDetails, name, actionEntry);
    
    handleDebugMessage("Action '" + name + "' added successfully.", true);
    
    save_actions();
}

//function scr_add_action(argument0, argument1, argument2) {
//    var name = string(argument0);
//    var commandName = string(argument1);
//    var parameters = argument2; // This should be an array
    
//    handleDebugMessage("Adding action: " + name + ", Command: " + commandName + ", Parameters: " + string(parameters), true);

//    // Ensure the action doesn't already exist
//    if (ds_map_exists(global.actionDetails, name)) {
//        handleDebugMessage("Action '" + name + "' already exists.", true);
//        return;
//    }
    
//    // Ensure the command is valid and exists
//    var commandDetailName = commandName + "(";
//    handleDebugMessage("Checking for command: " + commandDetailName, true);
//    if (!ds_map_exists(global.commandDetails, commandDetailName)) {
//        handleDebugMessage("Command '" + commandName + "' does not exist.", true);
//        return;
//    }
    
//    // Ensure parameters is an array
//    if (!is_array(parameters)) {
//        parameters = [parameters];
//    } else if (array_length(parameters) == 1 && is_string(parameters[0])) {
//        // If it's a single string that looks like an array, split it
//        var paramString = string_replace_all(parameters[0], "[", "");
//        paramString = string_replace_all(paramString, "]", "");
//        parameters = string_split(paramString, ",");
//    }
    
//    // Process each parameter
//    for (var i = 0; i < array_length(parameters); i++) {
//        var param = parameters[i];
//        // Remove quotes if present
//        if (is_string(param)) {
//            param = string_replace_all(param, "\"", "");
//            param = string_trim(param);
//            // Convert to number if it's a valid number
//            if (string_digits(param) == param) {
//                param = real(param);
//            }
//        }
//        parameters[i] = param;
//    }
    
//    handleDebugMessage("Parameters after processing: " + string(parameters), true);
    
//    // Create the action entry
//    var actionEntry = ds_map_create();
//    ds_map_add(actionEntry, "command", commandName);
//    ds_map_add(actionEntry, "parameters", parameters);
    
//    // Add the action entry to the global action details
//    ds_map_add(global.actionDetails, name, actionEntry);
    
//    handleDebugMessage("Action '" + name + "' added successfully.", true);
    
//    // Save the action to the file
//    save_actions();
//}


Script: save_actions
File: save_actions.gml
Code:
function save_actions() {
    if (ds_map_size(global.actionDetails) == 0) {
        handleDebugMessage("No actions to save.", true);
        return;
    }
    
    var file = file_text_open_write("Actions.txt");
    var actionKey = ds_map_find_first(global.actionDetails);
    
    while (!is_undefined(actionKey)) {
        var actionData = ds_map_find_value(global.actionDetails, actionKey);
        var command = actionData[? "command"];
        var parameters = actionData[? "parameters"];
        
        var paramString = "";
        for (var i = 0; i < array_length(parameters); i++) {
            var param = parameters[i];
            if (is_string(param)) {
                paramString += "\"" + string_replace_all(param, "\"", "\\\"") + "\"";
            } else {
                paramString += string(param);
            }
            if (i < array_length(parameters) - 1) {
                paramString += ",";
            }
        }
        
        file_text_write_string(file, actionKey + "," + command + "," + paramString);
        file_text_writeln(file);
        actionKey = ds_map_find_next(global.actionDetails, actionKey);
    }
    
    file_text_close(file);
    handleDebugMessage("Actions saved successfully to Actions.txt.", true);
}

//old code

///// @function save_actions()
///// @description Saves the global.actionDetails to Actions.txt
//function save_actions() {
//    if (ds_map_size(global.actionDetails) == 0) {
//        handleDebugMessage("No actions to save.", true);
//        return;
//    }

//    var file = file_text_open_write("Actions.txt");
//    var actionKey = ds_map_find_first(global.actionDetails);

//    // Iterate over each action entry and save it in the desired format
//    while (actionKey != undefined) {
//        var actionData = ds_map_find_value(global.actionDetails, actionKey);
//        var command = actionData[? "command"];
//        var parameters = actionData[? "parameters"];

//        // Format the parameters correctly
//        var paramsString = "[ ";
//        for (var i = 0; i < array_length(parameters); i++) {
//            var param = parameters[i];

//            // Convert param to the appropriate data type string
//            if (is_real(param) || string_is_real(param)) {
//                paramsString += string(real(param));
//            } else if (is_string(param)) {
//                paramsString += "\"" + string_trim(param) + "\"";
//            }

//            if (i < array_length(parameters) - 1) {
//                paramsString += ", ";
//            }
//        }
//        paramsString += " ]";

//        file_text_write_string(file, actionKey + "," + command + "," + paramsString);
//        file_text_writeln(file);

//        actionKey = ds_map_find_next(global.actionDetails, actionKey);
//    }

//    file_text_close(file);
//    handleDebugMessage("Actions saved successfully to Actions.txt.", true);
//}







Script: save_actions
File: save_actions.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"save_actions",
  "isCompatibility":false,
  "isDnD":false,
  "name":"save_actions",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: scr_execute_action
File: scr_execute_action.gml
Code:
function scr_execute_action() {
    if (argument_count == 0) {
        handleDebugMessage("Error: No action name provided for execute_action", true);
        return;
    }

    var actionName = argument[0];
    if (ds_map_exists(global.actionDetails, actionName)) {
        var actionData = ds_map_find_value(global.actionDetails, actionName);
        if (!ds_map_exists(actionData, "command") || !ds_map_exists(actionData, "parameters")) {
            handleDebugMessage("Error: Invalid action format for '" + actionName + "'.", true);
            return;
        }
        
        var command = ds_map_find_value(actionData, "command");
        var params = ds_map_find_value(actionData, "parameters");
        
        // Construct the command string and execute it
        var commandString = command + "(";
        for (var i = 0; i < array_length(params); i++) {
            if (is_string(params[i])) {
                commandString += "\"" + string_replace_all(params[i], "\"", "\\\"") + "\"";
            } else {
                commandString += string(params[i]);
            }
            if (i < array_length(params) - 1) {
                commandString += ", ";
            }
        }
        commandString += ")";
        
        handleDebugMessage("Executing action: " + commandString, true);
        execute_command(commandString);
    } else {
        handleDebugMessage("Action '" + actionName + "' not found.", true);
    }
}













Script: scr_execute_action
File: scr_execute_action.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"scr_execute_action",
  "isCompatibility":false,
  "isDnD":false,
  "name":"scr_execute_action",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: handleDebugMessage
File: handleDebugMessage.gml
Code:
/// @function handleDebugMessage(msg, isDebug)
/// @description Logs messages to the debug console and files, and manages chat display
/// @param {string} msg - The message to log
/// @param {bool} isDebug - True if this is a debug message, false for essential messages
function handleDebugMessage(msg, isDebug) {
    var safeMsg = is_string(msg) ? msg : "Undefined message content";
    var currentDate = date_current_datetime();
    var formattedDate = date_date_string(currentDate);
    var formattedTime = date_time_string(currentDate);
    var logMsg = formattedDate + " " + formattedTime + ": " + safeMsg + "\n";

    show_debug_message("Date: " + formattedDate + " Time: " + formattedTime + " Msg: " + safeMsg);

    // Function to handle file logging
    function logToFile(filePath, message) {
        var file;
        if (file_exists(filePath)) {
            file = file_text_open_append(filePath);
        } else {
            file = file_text_open_write(filePath);
        }
        file_text_write_string(file, message);
        file_text_close(file);
    }

    logToFile(working_directory + global.sessionLogFileName, logMsg);
    logToFile(working_directory + global.masterLogFileName, logMsg);

    // Update the chat system and possibly calculate WPM
    if (isDebug && global.showDebugMessages) {
        if (ds_list_size(global.debugMessages) >= global.maximumMessages) {
            ds_list_delete(global.debugMessages, 0); // Keep the latest messages
        }
        ds_list_add(global.debugMessages, safeMsg);

        // Before drawing chat messages, ensure messages is a valid ds_list
        if (!ds_exists(global.debugMessages, ds_type_list)) {
            show_debug_message("Error: debugMessages is not a valid ds_list.");
            return;
        }

        var totalLines = drawChatMessages(global.debugMessages, 990, 0, global.max_visible_lines, .5, false, global.c_chat2, global.c_chat1);
        if (totalLines - obj_Client.scrollIndex > global.max_visible_lines) {
            var totalLines_inRecentMessage = is_string(msg) ? countLinesInString(msg) : 1;
            obj_Client.scrollIndex = totalLines; // Scroll to bottom when new message
            obj_Client.scrollIndex -= (clamp(totalLines_inRecentMessage - 1, 0, 999999)); // Scroll back up number of lines in newest message (-1)
        }
        if (obj_Client.scrollIndex > totalLines) {
            // Clamp scroll
            obj_Client.scrollIndex = clamp(totalLines, 0, 99999);
        }
        draw_set_font(obj_Client.fnt_chat);
        global.longestmessage = updateLongestMessage(global.debugMessages);
    }

    // Create a chat bubble when no command is entered
    if (isDebug = 1) and !(string_char_at(safeMsg,0) = "/") {
        global.bubble_send_to_log = 0; // Don't send message to chat log
        var cleanMsg = string_remove_between(safeMsg, "[", "]");
        cleanMsg = string_replace_all(cleanMsg, "\n", " ");  // Remove existing line breaks
		if global.message_is_bubble=1 {
        scr_chat_bubble(cleanMsg, "yeancat");
		}
        global.bubble_send_to_log = 1; // Reset the variable
    }

    // WPM Calculation Logic Integration
    if (isDebug) {  // Assuming non-debug messages are chat messages
        var wordCount = string_word_count(safeMsg);
        var messageDetails = [currentDate, wordCount];
        ds_list_add(global.chatLogs, messageDetails);
        updateWPM();  // This would be a new function to handle WPM updates based on chatLogs
    }
}






///// @function handleDebugMessage(msg, isDebug)
///// @param {string} msg - The message to log
///// @param {bool} isDebug - True if this is a debug message, false for essential messages
//function handleDebugMessage(msg, isDebug) {
//    var safeMsg = is_string(msg) ? msg : "Undefined message content";
//    var currentDate = date_current_datetime();
//    var formattedDate = date_date_string(currentDate);
//    var formattedTime = date_time_string(currentDate);
//    var logMsg = formattedDate + " " + formattedTime + ": " + safeMsg + "\n";

//    show_debug_message("Date: " + formattedDate + " Time: " + formattedTime + " Msg: " + safeMsg);

//    // Function to handle file logging
//    function logToFile(filePath, message) {
//        var file;
//        if (file_exists(filePath)) {
//            file = file_text_open_append(filePath);
//        } else {
//            file = file_text_open_write(filePath);
//        }
//        file_text_write_string(file, message);
//        file_text_close(file);
//    }

//    logToFile(working_directory + global.sessionLogFileName, logMsg);
//    logToFile(working_directory + global.masterLogFileName, logMsg);

//    if (isDebug && global.showDebugMessages) {
//        if (ds_list_size(obj_Client.debugMessages) >= global.maximumMessages) {
//            ds_list_delete(obj_Client.debugMessages, 0); // Keep the latest messages
//        }
//        ds_list_add(debugMessages, safeMsg);
//		if show_chatbox and ds_exists(debugMessages, ds_type_list) {
//			// Before calling drawChatMessages, ensure messages is a ds_list
//if (!ds_exists(debugMessages, ds_type_list)) {
//    show_debug_message("Error: debugMessages is not a valid ds_list.");
//    return;
//}

//var totalLines = drawChatMessages(debugMessages, 990, 0, global.max_visible_lines, .5, false,global.c_chat2,global.c_chat1);
//		if (totalLines-obj_Client.scrollIndex>global.max_visible_lines) {
//			var totalLines_inRecentMessage = 1
//			if is_string(msg) {
//			totalLines_inRecentMessage = countLinesInString(msg)
//			}
//			obj_Client.scrollIndex = totalLines //scroll to bottom when new message
//            obj_Client.scrollIndex -= (clamp(totalLines_inRecentMessage-1,0,999999)); //scroll back up number of lines in newest message (-1)
//        }
//        if (obj_Client.scrollIndex>totalLines ) {
//			//clamp scroll
//            obj_Client.scrollIndex = clamp(totalLines,0,99999);
//        }
//        draw_set_font(obj_Client.fnt_chat);
//        global.longestmessage = updateLongestMessage(debugMessages);	
//		}
//    }
//}



Script: handleDebugMessage
File: handleDebugMessage.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"handleDebugMessage",
  "isCompatibility":false,
  "isDnD":false,
  "name":"handleDebugMessage",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: execute_command
File: execute_command.gml
Code:
function execute_command(command) {
    handleDebugMessage("Executing command: " + command, true);

    command = string_trim(command);
    if (command == "") {
        handleDebugMessage("Error: Empty command", true);
        return;
    }

    if (string_char_at(command, 1) == "/") {
        command = string_delete(command, 1, 1);
    }
    handleDebugMessage("Processed command: " + command, true);

    var commandName = "";
    var parameters = [];

    if (string_pos("add_action(", command) == 1) {
        var startParen = string_pos("(", command);
        var endParen = string_last_pos(")", command);
        if (startParen > 0 && endParen > startParen) {
            var argsString = string_copy(command, startParen + 1, endParen - startParen - 1);
            var args = string_split(argsString, ",");
            if (array_length(args) >= 3) {
                var actionName = string_trim(args[0]);
                var actionCommand = string_trim(args[1]);
                var actionParams = string_join_ext(",", args, 2);
                actionParams = string_replace_all(actionParams, "[", "");
                actionParams = string_replace_all(actionParams, "]", "");
                var paramArray = string_split(actionParams, ",");
                for (var i = 0; i < array_length(paramArray); i++) {
                    paramArray[i] = string_trim(paramArray[i]);
                }
                scr_add_action(actionName, actionCommand, paramArray);
                return;
            }
        }
    } else if (string_pos("execute_action(", command) == 1) {
        var actionName = string_replace(command, "execute_action(", "");
        actionName = string_replace(actionName, ")", "");
        actionName = string_trim(actionName);
        
        if (ds_map_exists(global.actionDetails, actionName)) {
            var actionEntry = ds_map_find_value(global.actionDetails, actionName);
            commandName = ds_map_find_value(actionEntry, "command");
            parameters = ds_map_find_value(actionEntry, "parameters");
        } else {
            handleDebugMessage("Action '" + actionName + "' not found.", true);
            return;
        }
    } else {
        var startParenthesis = string_pos("(", command);
        var endParenthesis = string_pos(")", command);
        
        if (startParenthesis > 0 && endParenthesis > startParenthesis) {
            commandName = string_trim(string_copy(command, 1, startParenthesis - 1));
            var paramString = string_copy(command, startParenthesis + 1, endParenthesis - startParenthesis - 1);
            parameters = string_split(paramString, ",");
            
            for (var i = 0; i < array_length(parameters); i++) {
                var param = string_trim(parameters[i]);
                if (string_char_at(param, 1) == "\"" && string_char_at(param, string_length(param)) == "\"") {
                    param = string_copy(param, 2, string_length(param) - 2);
                } else if (string_digits(param) == param) {
                    param = real(param);
                }
                parameters[i] = param;
            }

            if (commandName == "chat_bubble") {
                var text = parameters[0];
                var owner = parameters[1];
                var choices = [];
                
                if (array_length(parameters) > 2 && is_array(parameters[2])) {
                    var choicesArray = parameters[2];
                    for (var i = 0; i < array_length(choicesArray); i++) {
                        if (is_array(choicesArray[i]) && array_length(choicesArray[i]) == 2) {
                            array_push(choices, choicesArray[i]);
                        }
                    }
                }
                
                scr_chat_bubble(text, owner, choices);
                return;
            }
        } else {
            commandName = command;
        }
    }

    var scriptName = "scr_" + commandName;
    
    if (script_exists(asset_get_index(scriptName))) {
        script_execute_ext(asset_get_index(scriptName), parameters);
    } else {
        handleDebugMessage("Script not found for command: " + commandName, true);
    }
}

Script: execute_command
File: execute_command.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"execute_command",
  "isCompatibility":false,
  "isDnD":false,
  "name":"execute_command",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: update_chat_input_visuals
File: update_chat_input_visuals.gml
Code:
function update_chat_input_visuals() {
    var inputText = string_trim(global.commandBuffer);
    var firstChar = string_char_at(inputText, 1);
    
    if (inputText == "") {
        global.textColor = global.defaultTextColor;
        return;
    }
    
    if (firstChar != "/") {
        global.textColor = global.defaultTextColor;
        return;
    }
    
    if (string_length(inputText) == 1) {
        global.textColor = c_white;
        return;
    }
    
    var command = string_delete(inputText, 1, 1);
    var hasPermission = check_permission_command(command);
    var isZeroArgCommand = ds_map_exists(global.commandDetails, command) && !ds_map_exists(global.commandDetails, command + "(");
    
    if (isZeroArgCommand) {
        global.textColor = hasPermission ? c_lime : c_red;
    } else if (ds_map_exists(global.commandDetails, command + "(")) {
        var openParenPos = string_pos("(", inputText);
        if (openParenPos == 0) {
            global.textColor = c_aqua;
        } else {
            var closeParenPos = string_pos(")", inputText);
            if (closeParenPos > openParenPos) {
                global.textColor = hasPermission ? c_lime : c_red;
            } else {
                global.textColor = c_aqua;
            }
        }
    } else {
        global.textColor = c_pink;
    }
}
//// Function to update the color of the chatbox text based on command input
//function update_chat_input_visuals() {
//    var inputText = string_trim(global.commandBuffer);
//    var firstChar = string_char_at(inputText, 1);

//    if (inputText == "") {
//        global.textColor = global.defaultTextColor;
//    } else if (firstChar == "/") {
//        if (string_length(inputText) == 1) {
//            global.textColor = c_white; // Initial '/' is white
//        } else {
//            var commandEnd = string_pos(" ", inputText);
//            if (commandEnd == 0) commandEnd = string_length(inputText);
//            var argsStart = string_pos("(", inputText);
//            var argsEnd = string_pos(")", inputText);

//            // Adjust the commandEnd if "(" is part of the command
//            if (argsStart > 0 && argsStart < commandEnd) {
//                commandEnd = argsStart;
//            }
//            var command = string_copy(inputText, 2, commandEnd - 1);
//            var hasPermission = check_permission_command(command);

//            // Ensure the command is valid before changing the color based on arguments
//            if (ds_map_exists(global.commandDetails, command)) {
//                // Call handleCommandWithArgs to manage the text color based on command validation
//                global.textColor = handleCommandWithArgs(argsStart, argsEnd, command, hasPermission);
//            } else {
//                // If the command is not valid, do not turn it aqua just for typing '('
//                global.textColor = c_pink;  // Set to pink as the command is not recognized
//            }
//        }
//    } else {
//        global.textColor = global.defaultTextColor;
//    }
//}



//// Function to update the color of the chatbox text based on command input
//function update_chat_input_visuals() {
//    var inputText = string_trim(global.commandBuffer);
//    var firstChar = string_char_at(inputText, 1);

//    if (inputText == "") {
//        global.textColor = global.defaultTextColor;
//    } else if (firstChar == "/") {
//        if (string_length(inputText) == 1) {
//            global.textColor = c_white; // Initial '/' is white
//        } else {
//            var commandEnd = string_pos(" ", inputText);
//            if (commandEnd == 0) commandEnd = string_length(inputText);
//            var argsStart = string_pos("(", inputText);
//            var argsEnd = string_pos(")", inputText);

//            // Adjust the commandEnd if "(" is part of the command
//            if (argsStart > 0 && argsStart < commandEnd) {
//                commandEnd = argsStart;
//            }
//            var command = string_copy(inputText, 2, commandEnd - 1);
//            var hasPermission = check_permission_command(command);

//            // Ensure the command is valid before changing the color based on arguments
//            if (ds_map_exists(global.commandDetails, command)) {
//                // Extract and validate array arguments
//                var argsString = string_copy(inputText, argsStart + 1, argsEnd - argsStart - 1);
//                var isValidArray = true;

//                if (string_pos("[", argsString) > 0 && string_pos("]", argsString) > 0) {
//                    var arrayStart = string_pos("[", argsString);
//                    var arrayEnd = string_pos("]", argsString);
//                    var arrayString = string_copy(argsString, arrayStart + 1, arrayEnd - arrayStart - 1);
//                    var arrayParams = string_split(arrayString, ",");

//                    // Check if each element is a valid parameter
//                    for (var i = 0; i < array_length(arrayParams); i++) {
//                        if (string_trim(arrayParams[i]) == "") {
//                            isValidArray = false;
//                            break;
//                        }
//                    }
//                }

//                // Check if command parameters are valid
//                if (isValidArray) {
//                    global.textColor = handleCommandWithArgs(argsStart, argsEnd, command, hasPermission);
//                } else {
//                    global.textColor = c_pink; // Set to pink if the array is invalid
//                }
//            } else {
//                global.textColor = c_pink;  // Set to pink if the command is not recognized
//            }
//        }
//    } else {
//        global.textColor = global.defaultTextColor;
//    }
//}



//// Function to update the color of the chatbox text based on command input
//function update_chat_input_visuals() {
//    var inputText = string_trim(global.commandBuffer);
//    var firstChar = string_char_at(inputText, 1);

//    if (inputText == "") {
//        global.textColor = global.defaultTextColor;
//    } else if (firstChar == "/") {
//        if (string_length(inputText) == 1) {
//            global.textColor = c_white; // Initial '/' is white
//        } else {
//            var commandEnd = string_pos(" ", inputText);
//            if (commandEnd == 0) commandEnd = string_length(inputText);
//            var argsStart = string_pos("(", inputText);
//            var argsEnd = string_pos(")", inputText);

//            // Adjust the commandEnd if "(" is part of the command
//            if (argsStart > 0 && argsStart < commandEnd) {
//                commandEnd = argsStart;
//            }
//            var command = string_copy(inputText, 2, commandEnd - 1);
//            var hasPermission = check_permission_command(command);

//            // Ensure the command is valid before changing the color based on arguments
//            if (ds_map_exists(global.commandDetails, command)) {
//                // Extract and validate array arguments
//                var argsString = string_copy(inputText, argsStart + 1, argsEnd - argsStart - 1);
//                var isValidArray = true;

//                if (string_pos("[", argsString) > 0 && string_pos("]", argsString) > 0) {
//                    var arrayStart = string_pos("[", argsString);
//                    var arrayEnd = string_pos("]", argsString);
//                    var arrayString = string_copy(argsString, arrayStart + 1, arrayEnd - arrayStart - 1);
//                    var arrayParams = string_split(arrayString, ",");

//                    // Check if each element is a valid parameter
//                    for (var i = 0; i < array_length(arrayParams); i++) {
//                        if (string_trim(arrayParams[i]) == "") {
//                            isValidArray = false;
//                            break;
//                        }
//                    }
//                }

//                // Call `handleCommandWithArgs` to manage the text color based on command validation
//                if (isValidArray) {
//                    global.textColor = handleCommandWithArgs(argsStart, argsEnd, command, hasPermission);
//                } else {
//                    global.textColor = c_pink; // Set to pink if the array is invalid
//                }
//            } else {
//                // If the command is not valid, do not turn it aqua just for typing '('
//                global.textColor = c_pink;  // Set to pink as the command is not recognized
//            }
//        }
//    } else {
//        global.textColor = global.defaultTextColor;
//    }
//}










Script: update_chat_input_visuals
File: update_chat_input_visuals.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"update_chat_input_visuals",
  "isCompatibility":false,
  "isDnD":false,
  "name":"update_chat_input_visuals",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: parse_data_types
File: parse_data_types.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"parse_data_types",
  "isCompatibility":false,
  "isDnD":false,
  "name":"parse_data_types",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: parse_data_types
File: parse_data_types.gml
Code:
/// @function parse_data_types(argumentsArray)
/// @description Converts strings in an array to appropriate data types
function parse_data_types(argumentsArray) {
    var parsedArray = [];
    for (var i = 0; i < array_length(argumentsArray); i++) {
        var arg = string_trim(argumentsArray[i]);

        // Parse as array
        if (string_char_at(arg, 1) == "[" && string_char_at(arg, string_length(arg)) == "]") {
            parsedArray[i] = parse_data_types(parse_arguments(string_copy(arg, 2, string_length(arg) - 2)));
        }
        // Parse as real
        else if (string_is_real(arg)) {
            parsedArray[i] = real(arg);
        }
        // Treat as a string
        else {
            parsedArray[i] = arg;
        }
    }
    return parsedArray;
}

//old code
//// Function to convert string arguments into their appropriate data types
//function parse_data_types(arguments) {
//    var parsedArguments = [];
//    var currentArg;

//    for (var i = 0; i < array_length(arguments); i++) {
//        currentArg = string_trim(arguments[i]);

//        // Detect if the argument is an array
//        if (string_char_at(currentArg, 1) == "[" && string_char_at(currentArg, string_length(currentArg)) == "]") {
//            // Remove brackets and split the inner array by commas
//            currentArg = string_copy(currentArg, 2, string_length(currentArg) - 2);
//            var innerArray = parse_arguments(currentArg);
//            parsedArguments[array_length(parsedArguments)] = parse_data_types(innerArray);
//        }
//        // Detect if the argument is a real number
//        else if (is_real(currentArg) || string_is_real(currentArg)) {
//            parsedArguments[array_length(parsedArguments)] = real(currentArg);
//        }
//        // Otherwise, it's a string
//        else {
//            parsedArguments[array_length(parsedArguments)] = currentArg;
//        }
//    }

//    return parsedArguments;
//}


Script: parse_arguments
File: parse_arguments.yy
Code:
{
  "$GMScript":"v1",
  "%Name":"parse_arguments",
  "isCompatibility":false,
  "isDnD":false,
  "name":"parse_arguments",
  "parent":{
    "name":"Scripts",
    "path":"folders/Scripts.yy",
  },
  "resourceType":"GMScript",
  "resourceVersion":"2.0",
}

Script: parse_arguments
File: parse_arguments.gml
Code:
/// @function parse_arguments(argsString)
/// @description Parses a string containing command arguments into an array
function parse_arguments(argsString) {
    var params = [];
    var inString = false;
    var inArray = false;
    var currentParam = "";
    var currentChar;

    for (var i = 1; i <= string_length(argsString); i++) {
        currentChar = string_char_at(argsString, i);

        if (currentChar == "\"" && !inArray) {
            inString = !inString; // Toggle string mode
            currentParam += currentChar;
        } else if (currentChar == "[" && !inString) {
            inArray = true;
            currentParam += currentChar;
        } else if (currentChar == "]" && !inString) {
            inArray = false;
            currentParam += currentChar;
        } else if (currentChar == "," && !inString && !inArray) {
            params[array_length(params)] = string_trim(currentParam);
            currentParam = "";
        } else {
            currentParam += currentChar;
        }
    }

    if (string_length(currentParam) > 0) {
        // Remove surrounding quotes if the entire parameter is a quoted string
        if (string_length(currentParam) >= 2 && string_char_at(currentParam, 1) == "\"" && string_char_at(currentParam, string_length(currentParam)) == "\"") {
            currentParam = string_delete(currentParam, string_length(currentParam), 1);
            currentParam = string_delete(currentParam, 1, 1);
        }

        params[array_length(params)] = string_trim(currentParam);
    }

    return params;
}

== Related Logs ==
