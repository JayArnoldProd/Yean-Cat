
------ GIT_GPT_SERVER/scripts/__init__.py ------


------ GIT_GPT_SERVER/scripts/backup.sh ------
#!/bin/bash
# backup.sh

echo "Starting backup script..."

# Update lists
./GIT_GPT_SERVER/scripts/update_lists.sh
echo "Backed up Lists!"

# Define directories and files to be backed up
directories=(
    "GIT_GPT_SERVER/scripts"
    "GIT_GPT_SERVER/Logs"
    "GIT_GPT_SERVER/.github"
    "GIT_GPT_SERVER/routes"
    "GIT_GPT_SERVER/tests"
    "GIT_GPT_SERVER/utils"
    "GIT_GPT_SERVER/prompts"
)

# Define miscellaneous files including those in the root directory
misc_files=(
    "GIT_GPT_SERVER/__init__.py"
    "GIT_GPT_SERVER/config.py"
    "GIT_GPT_SERVER/flask_pid.txt"
    "GIT_GPT_SERVER/format_description.txt"
    "GIT_GPT_SERVER/intro.txt"
    "GIT_GPT_SERVER/server.py"
    "README.md"
    "script_list.txt"
    "bug_list.json"
    "command_list.txt"
    "package.json"
    ".slugignore"
    ".env"
    "requirements.txt"
    "planned_features.json"
    ".gitignore"
    "pyproject.toml"
    "Procfile"
    ".gitattributes"
    "server_script_list.txt"
    "runtime.txt"
    "server_command_list.txt"
)

# Logical groups for miscellaneous files
group1=("README.md" "GIT_GPT_SERVER/intro.txt" "GIT_GPT_SERVER/format_description.txt")
group2=("GIT_GPT_SERVER/__init__.py" "GIT_GPT_SERVER/config.py" "GIT_GPT_SERVER/flask_pid.txt" "GIT_GPT_SERVER/server.py")
group3=("script_list.txt" "command_list.txt" "server_script_list.txt" "server_command_list.txt")
group4=("bug_list.json" "planned_features.json" "package.json" "requirements.txt" "pyproject.toml")
group5=(".gitignore" ".gitattributes" ".slugignore" ".env" "Procfile")

# Function to backup a directory
backup_directory() {
    local directory=$1
    local output_file=$2
    echo "Backing up files from $directory to $output_file..."
    for file in "$directory"/*; do
        if [ -f "$file" ]; then
            echo "Processing $file"
            echo -e "
------ $file ------
$(cat "$file")" >> "$output_file"
        fi
    done
}

# Function to backup a group of files
backup_group() {
    local group=("$@")
    local output_file=$1
    shift
    echo "Backing up group of files to $output_file..."
    for file in "${group[@]}"; do
        if [ -f "$file" ]; then
            echo "Processing $file"
            echo -e "
------ $file ------
$(cat "$file")" >> "$output_file"
        fi
    done
}

# Backup each specified directory
for dir in "${directories[@]}"; do
    dir_name=$(basename "$dir")
    backup_directory "$dir" "GIT_GPT_SERVER/code_backups/${dir_name}_backup.txt"
done

# Backup miscellaneous files in logical groups
backup_group "GIT_GPT_SERVER/code_backups/documentation_backup.txt" "${group1[@]}"
backup_group "GIT_GPT_SERVER/code_backups/config_backup.txt" "${group2[@]}"
backup_group "GIT_GPT_SERVER/code_backups/script_lists_backup.txt" "${group3[@]}"
backup_group "GIT_GPT_SERVER/code_backups/metadata_backup.txt" "${group4[@]}"
backup_group "GIT_GPT_SERVER/code_backups/git_files_backup.txt" "${group5[@]}"

# Copy files to code_text directory
copy_to_code_text() {
    local source_file=$1
    local target_file=$2
    echo "Copying $source_file to $target_file..."
    mkdir -p "$(dirname "$target_file")"
    cp "$source_file" "$target_file"
}

# Ensure all necessary files are copied correctly
copy_files() {
    local dir=$1
    for file in "$dir"/*; do
        if [ -f "$file" ]; then
            local target_file="GIT_GPT_SERVER/code_text/${file}.txt"
            copy_to_code_text "$file" "$target_file"
        elif [ -d "$file" ]; then
            copy_files "$file"
        fi
    done
}

# Copy the directories to code_text
copy_files "GIT_GPT_SERVER"

# Copy root directory files to root_code_text
for file in "${misc_files[@]}"; do
    if [ -f "$file" ]; then
        local target_file="root_code_text/${file}.txt"
        copy_to_code_text "$file" "$target_file"
    fi
done

# Generate hierarchy
echo "Generating hierarchy..."
./GIT_GPT_SERVER/scripts/generate_hierarchy.sh

echo "Backup completed successfully!"

------ GIT_GPT_SERVER/scripts/deploy.sh ------
#!/bin/bash

# Navigate to the project directory
cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat

# Push to Heroku
git push heroku main

------ GIT_GPT_SERVER/scripts/deploy_all.sh ------
#!/bin/bash
# deploy_all.sh

# Step 1: Set environment variables from .env
source .env

# Step 2: Update GitHub remote URL with token
echo "Updating GitHub remote URL..."
git remote set-url origin https://JayArnoldProd:${GITHUB_TOKEN}@github.com/JayArnoldProd/Yean-Cat.git

# Step 3: Run backup script with hierarchy generation
echo "Running backup script..."
./GIT_GPT_SERVER/scripts/backup.sh

# Step 4: Identify and kill specific Flask processes
echo "Checking for and killing existing Flask servers on ports 5000..."
./GIT_GPT_SERVER/scripts/stop_server.sh

# Step 5: Add and commit changes to GitHub (without push)
echo "Adding and committing changes to GitHub..."
git add .
git commit -m "Automated backup and deployment"

# Notify about manual Git operations
echo "Please manually push changes using GitHub Desktop."

# Step 6: Check if the server is running and pull logs
if curl -s --head http://localhost:5000 | grep "200 OK" > /dev/null; then
    echo "Pulling logs from the server..."
    curl -X POST http://localhost:5000/api/update_code/pull_logs -o Logs/server_logs.json
else
    echo "Server is not running. Starting the Flask server..."
    cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat/GIT_GPT_SERVER
    export FLASK_APP=server.py
    flask run &
    sleep 5  # Wait for the server to start
    echo "Pulling logs from the server..."
    curl -X POST http://localhost:5000/api/update_code/pull_logs -o Logs/server_logs.json
fi

echo "Backup and deployment completed successfully!"

# Step 7: Save Flask server PID
FLASK_PID=$!
echo $FLASK_PID > /Users/joshuaarnold/Documents/GitHub/Yean-Cat/GIT_GPT_SERVER/flask_pid.txt

## Step 8: Run test API endpoints script
#echo "Running test API endpoints script..."
#if [ -f /Users/joshuaarnold/Documents/GitHub/Yean-Cat/GIT_GPT_SERVER/scripts/tests/test_api_endpoints.py ]; then
#    python /Users/joshuaarnold/Documents/GitHub/Yean-Cat/GIT_GPT_SERVER/scripts/tests/test_api_endpoints.py
#else
#    echo "Test script not found."
#fi

# Navigate to the project directory
cd /Users/joshuaarnold/Documents/GitHub/Yean-Cat

# Push to Heroku
git push heroku main

echo "Deployment and run completed successfully!"

------ GIT_GPT_SERVER/scripts/generate_hierarchy.sh ------
#!/bin/bash

# Create a hierarchies directory in the root
mkdir -p hierarchies

# Function to create a hierarchical representation of a directory
generate_hierarchy() {
    local directory=$1
    local output_file=$2
    local depth=$3

    echo "Generating hierarchy for $directory..."
    if [ -z "$depth" ]; then
        tree "$directory" -o "$output_file" || { echo "Failed to generate hierarchy for $directory"; exit 1; }
    else
        tree -L "$depth" "$directory" -o "$output_file" || { echo "Failed to generate hierarchy for $directory"; exit 1; }
    fi
    echo "Hierarchy generated at $output_file"
}

# Generate hierarchies for the required directories and save in the hierarchies folder
generate_hierarchy "GIT_GPT_SERVER" "hierarchies/GIT_GPT_SERVER_hierarchy.txt"
generate_hierarchy "YEAN_CAT" "hierarchies/YEAN_CAT_hierarchy.txt" 5
generate_hierarchy "YEAN_CAT_SERVER" "hierarchies/YEAN_CAT_SERVER_hierarchy.txt"

# Generate top-level hierarchy for Yean-Cat without including files within subdirectories
generate_hierarchy "." "hierarchies/Yean-Cat_hierarchy.txt" 1

echo "Hierarchy creation completed successfully!"

------ GIT_GPT_SERVER/scripts/print_env.py ------
# print_env.py
from dotenv import load_dotenv
import os

load_dotenv()

print("GITHUB_API_URL:", os.getenv('GITHUB_API_URL'))
print("GITHUB_TOKEN:", os.getenv('GITHUB_TOKEN'))
print("ASSISTANT_ID:", os.getenv('ASSISTANT_ID'))  # Ensure this is correctly named in Heroku
print("PINECONE_API_KEY:", os.getenv('PINECONE_API_KEY'))
print("PINECONE_INDEX_NAME:", os.getenv('PINECONE_INDEX_NAME'))
print("GITHUB_USERNAME:", os.getenv('GITHUB_USERNAME'))

------ GIT_GPT_SERVER/scripts/stop_server.sh ------
#!/bin/bash
# stop_server.sh

# Function to kill a process using a specific port
kill_process_on_port() {
    local port=$1
    echo "Checking for existing server on port $port..."
    PID=$(lsof -t -i:$port)
    if [ ! -z "$PID" ]; then
        echo "Killing process $PID using port $port..."
        kill -9 $PID
    else
        echo "No process using port $port."
    fi
}

# Kill servers on specified ports
kill_process_on_port 5000
kill_process_on_port 5001

# Optionally, kill the Flask server using the PID saved in flask_pid.txt
FLASK_PID_FILE="/Users/joshuaarnold/Documents/GitHub/Yean-Cat/GIT_GPT_SERVER/flask_pid.txt"
if [ -f "$FLASK_PID_FILE" ]; then
    echo "Killing Flask server using PID from $FLASK_PID_FILE..."
    FLASK_PID=$(cat "$FLASK_PID_FILE")
    if [ ! -z "$FLASK_PID" ]; then
        kill -9 $FLASK_PID
        echo "Flask server with PID $FLASK_PID has been killed."
        rm "$FLASK_PID_FILE"
    else
        echo "No Flask server PID found in $FLASK_PID_FILE."
    fi
else
    echo "$FLASK_PID_FILE not found."
fi

echo "Server shutdown completed successfully!"

------ GIT_GPT_SERVER/scripts/update_lists.sh ------
#!/bin/bash
# update_lists.sh

# Function to generate script list
generate_script_list() {
  local directory=$1
  local output_file=$2

  echo "Generating script list for $directory..."
  find "$directory" -name "*.gml" -exec basename {} .gml \; > "$output_file"
  echo "Script list generated at $output_file"
}

# Function to generate command list
generate_command_list() {
  local directory=$1
  local output_file=$2

  echo "Generating command list for $directory..."
  grep -r "function scr_" "$directory" | awk -F'function scr_' '{print $2}' | awk -F'(' '{print $1}' | sort -u > "$output_file"
  echo "Command list generated at $output_file"
}

# Generate lists for client project
generate_script_list "YEAN_CAT/scripts" "script_list.txt"
generate_command_list "YEAN_CAT/scripts" "command_list.txt"

# Generate lists for server project
generate_script_list "YEAN_CAT_SERVER/scripts" "server_script_list.txt"
generate_command_list "YEAN_CAT_SERVER/scripts" "server_command_list.txt"

# Commit and push the updated lists
git add script_list.txt command_list.txt server_script_list.txt server_command_list.txt
git commit -m "Update script and command lists"

echo "Update completed successfully!"
